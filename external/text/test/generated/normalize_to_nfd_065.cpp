// Copyright (C) 2020 T. Zachary Laine
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// Warning! This file is autogenerated.
#include <boost/text/normalize_string.hpp>
#include <boost/text/transcode_view.hpp>
#include <boost/text/string_utility.hpp>

#include <gtest/gtest.h>

#include <algorithm>



TEST(normalization, nfd_065_000)
{
    // D558;D558;1112 1161;D558;1112 1161; 
    // (하; 하; 하; 하; 하; ) HANGUL SYLLABLE HA
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD558 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD558 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1112, 0x1161 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD558 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1112, 0x1161 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_001)
{
    // D559;D559;1112 1161 11A8;D559;1112 1161 11A8; 
    // (학; 학; 학; 학; 학; ) HANGUL SYLLABLE HAG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD559 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD559 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD559 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_002)
{
    // D55A;D55A;1112 1161 11A9;D55A;1112 1161 11A9; 
    // (핚; 핚; 핚; 핚; 핚; ) HANGUL SYLLABLE HAGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD55A }};
        std::array<uint32_t, 1> const c2 = {{ 0xD55A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD55A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_003)
{
    // D55B;D55B;1112 1161 11AA;D55B;1112 1161 11AA; 
    // (핛; 핛; 핛; 핛; 핛; ) HANGUL SYLLABLE HAGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD55B }};
        std::array<uint32_t, 1> const c2 = {{ 0xD55B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xD55B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_004)
{
    // D55C;D55C;1112 1161 11AB;D55C;1112 1161 11AB; 
    // (한; 한; 한; 한; 한; ) HANGUL SYLLABLE HAN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD55C }};
        std::array<uint32_t, 1> const c2 = {{ 0xD55C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xD55C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_005)
{
    // D55D;D55D;1112 1161 11AC;D55D;1112 1161 11AC; 
    // (핝; 핝; 핝; 핝; 핝; ) HANGUL SYLLABLE HANJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD55D }};
        std::array<uint32_t, 1> const c2 = {{ 0xD55D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xD55D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_006)
{
    // D55E;D55E;1112 1161 11AD;D55E;1112 1161 11AD; 
    // (핞; 핞; 핞; 핞; 핞; ) HANGUL SYLLABLE HANH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD55E }};
        std::array<uint32_t, 1> const c2 = {{ 0xD55E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xD55E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_007)
{
    // D55F;D55F;1112 1161 11AE;D55F;1112 1161 11AE; 
    // (핟; 핟; 핟; 핟; 핟; ) HANGUL SYLLABLE HAD
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD55F }};
        std::array<uint32_t, 1> const c2 = {{ 0xD55F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xD55F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_008)
{
    // D560;D560;1112 1161 11AF;D560;1112 1161 11AF; 
    // (할; 할; 할; 할; 할; ) HANGUL SYLLABLE HAL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD560 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD560 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xD560 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_009)
{
    // D561;D561;1112 1161 11B0;D561;1112 1161 11B0; 
    // (핡; 핡; 핡; 핡; 핡; ) HANGUL SYLLABLE HALG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD561 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD561 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD561 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_010)
{
    // D562;D562;1112 1161 11B1;D562;1112 1161 11B1; 
    // (핢; 핢; 핢; 핢; 핢; ) HANGUL SYLLABLE HALM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD562 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD562 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD562 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_011)
{
    // D563;D563;1112 1161 11B2;D563;1112 1161 11B2; 
    // (핣; 핣; 핣; 핣; 핣; ) HANGUL SYLLABLE HALB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD563 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD563 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD563 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_012)
{
    // D564;D564;1112 1161 11B3;D564;1112 1161 11B3; 
    // (핤; 핤; 핤; 핤; 핤; ) HANGUL SYLLABLE HALS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD564 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD564 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD564 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_013)
{
    // D565;D565;1112 1161 11B4;D565;1112 1161 11B4; 
    // (핥; 핥; 핥; 핥; 핥; ) HANGUL SYLLABLE HALT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD565 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD565 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD565 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_014)
{
    // D566;D566;1112 1161 11B5;D566;1112 1161 11B5; 
    // (핦; 핦; 핦; 핦; 핦; ) HANGUL SYLLABLE HALP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD566 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD566 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD566 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_015)
{
    // D567;D567;1112 1161 11B6;D567;1112 1161 11B6; 
    // (핧; 핧; 핧; 핧; 핧; ) HANGUL SYLLABLE HALH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD567 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD567 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD567 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_016)
{
    // D568;D568;1112 1161 11B7;D568;1112 1161 11B7; 
    // (함; 함; 함; 함; 함; ) HANGUL SYLLABLE HAM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD568 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD568 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD568 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_017)
{
    // D569;D569;1112 1161 11B8;D569;1112 1161 11B8; 
    // (합; 합; 합; 합; 합; ) HANGUL SYLLABLE HAB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD569 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD569 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD569 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_018)
{
    // D56A;D56A;1112 1161 11B9;D56A;1112 1161 11B9; 
    // (핪; 핪; 핪; 핪; 핪; ) HANGUL SYLLABLE HABS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD56A }};
        std::array<uint32_t, 1> const c2 = {{ 0xD56A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD56A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_019)
{
    // D56B;D56B;1112 1161 11BA;D56B;1112 1161 11BA; 
    // (핫; 핫; 핫; 핫; 핫; ) HANGUL SYLLABLE HAS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD56B }};
        std::array<uint32_t, 1> const c2 = {{ 0xD56B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xD56B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_020)
{
    // D56C;D56C;1112 1161 11BB;D56C;1112 1161 11BB; 
    // (핬; 핬; 핬; 핬; 핬; ) HANGUL SYLLABLE HASS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD56C }};
        std::array<uint32_t, 1> const c2 = {{ 0xD56C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xD56C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_021)
{
    // D56D;D56D;1112 1161 11BC;D56D;1112 1161 11BC; 
    // (항; 항; 항; 항; 항; ) HANGUL SYLLABLE HANG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD56D }};
        std::array<uint32_t, 1> const c2 = {{ 0xD56D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xD56D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_022)
{
    // D56E;D56E;1112 1161 11BD;D56E;1112 1161 11BD; 
    // (핮; 핮; 핮; 핮; 핮; ) HANGUL SYLLABLE HAJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD56E }};
        std::array<uint32_t, 1> const c2 = {{ 0xD56E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xD56E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_023)
{
    // D56F;D56F;1112 1161 11BE;D56F;1112 1161 11BE; 
    // (핯; 핯; 핯; 핯; 핯; ) HANGUL SYLLABLE HAC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD56F }};
        std::array<uint32_t, 1> const c2 = {{ 0xD56F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xD56F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_024)
{
    // D570;D570;1112 1161 11BF;D570;1112 1161 11BF; 
    // (핰; 핰; 핰; 핰; 핰; ) HANGUL SYLLABLE HAK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD570 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD570 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xD570 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_025)
{
    // D571;D571;1112 1161 11C0;D571;1112 1161 11C0; 
    // (핱; 핱; 핱; 핱; 핱; ) HANGUL SYLLABLE HAT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD571 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD571 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD571 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_026)
{
    // D572;D572;1112 1161 11C1;D572;1112 1161 11C1; 
    // (핲; 핲; 핲; 핲; 핲; ) HANGUL SYLLABLE HAP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD572 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD572 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD572 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_027)
{
    // D573;D573;1112 1161 11C2;D573;1112 1161 11C2; 
    // (핳; 핳; 핳; 핳; 핳; ) HANGUL SYLLABLE HAH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD573 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD573 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1161, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD573 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1161, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_028)
{
    // D574;D574;1112 1162;D574;1112 1162; 
    // (해; 해; 해; 해; 해; ) HANGUL SYLLABLE HAE
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD574 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD574 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1112, 0x1162 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD574 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1112, 0x1162 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_029)
{
    // D575;D575;1112 1162 11A8;D575;1112 1162 11A8; 
    // (핵; 핵; 핵; 핵; 핵; ) HANGUL SYLLABLE HAEG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD575 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD575 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD575 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_030)
{
    // D576;D576;1112 1162 11A9;D576;1112 1162 11A9; 
    // (핶; 핶; 핶; 핶; 핶; ) HANGUL SYLLABLE HAEGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD576 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD576 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD576 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_031)
{
    // D577;D577;1112 1162 11AA;D577;1112 1162 11AA; 
    // (핷; 핷; 핷; 핷; 핷; ) HANGUL SYLLABLE HAEGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD577 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD577 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xD577 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_032)
{
    // D578;D578;1112 1162 11AB;D578;1112 1162 11AB; 
    // (핸; 핸; 핸; 핸; 핸; ) HANGUL SYLLABLE HAEN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD578 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD578 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xD578 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_033)
{
    // D579;D579;1112 1162 11AC;D579;1112 1162 11AC; 
    // (핹; 핹; 핹; 핹; 핹; ) HANGUL SYLLABLE HAENJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD579 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD579 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xD579 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_034)
{
    // D57A;D57A;1112 1162 11AD;D57A;1112 1162 11AD; 
    // (핺; 핺; 핺; 핺; 핺; ) HANGUL SYLLABLE HAENH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD57A }};
        std::array<uint32_t, 1> const c2 = {{ 0xD57A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xD57A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_035)
{
    // D57B;D57B;1112 1162 11AE;D57B;1112 1162 11AE; 
    // (핻; 핻; 핻; 핻; 핻; ) HANGUL SYLLABLE HAED
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD57B }};
        std::array<uint32_t, 1> const c2 = {{ 0xD57B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xD57B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_036)
{
    // D57C;D57C;1112 1162 11AF;D57C;1112 1162 11AF; 
    // (핼; 핼; 핼; 핼; 핼; ) HANGUL SYLLABLE HAEL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD57C }};
        std::array<uint32_t, 1> const c2 = {{ 0xD57C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xD57C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_037)
{
    // D57D;D57D;1112 1162 11B0;D57D;1112 1162 11B0; 
    // (핽; 핽; 핽; 핽; 핽; ) HANGUL SYLLABLE HAELG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD57D }};
        std::array<uint32_t, 1> const c2 = {{ 0xD57D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD57D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_038)
{
    // D57E;D57E;1112 1162 11B1;D57E;1112 1162 11B1; 
    // (핾; 핾; 핾; 핾; 핾; ) HANGUL SYLLABLE HAELM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD57E }};
        std::array<uint32_t, 1> const c2 = {{ 0xD57E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD57E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_039)
{
    // D57F;D57F;1112 1162 11B2;D57F;1112 1162 11B2; 
    // (핿; 핿; 핿; 핿; 핿; ) HANGUL SYLLABLE HAELB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD57F }};
        std::array<uint32_t, 1> const c2 = {{ 0xD57F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD57F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_040)
{
    // D580;D580;1112 1162 11B3;D580;1112 1162 11B3; 
    // (햀; 햀; 햀; 햀; 햀; ) HANGUL SYLLABLE HAELS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD580 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD580 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD580 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_041)
{
    // D581;D581;1112 1162 11B4;D581;1112 1162 11B4; 
    // (햁; 햁; 햁; 햁; 햁; ) HANGUL SYLLABLE HAELT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD581 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD581 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD581 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_042)
{
    // D582;D582;1112 1162 11B5;D582;1112 1162 11B5; 
    // (햂; 햂; 햂; 햂; 햂; ) HANGUL SYLLABLE HAELP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD582 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD582 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD582 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_043)
{
    // D583;D583;1112 1162 11B6;D583;1112 1162 11B6; 
    // (햃; 햃; 햃; 햃; 햃; ) HANGUL SYLLABLE HAELH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD583 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD583 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD583 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_044)
{
    // D584;D584;1112 1162 11B7;D584;1112 1162 11B7; 
    // (햄; 햄; 햄; 햄; 햄; ) HANGUL SYLLABLE HAEM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD584 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD584 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD584 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_045)
{
    // D585;D585;1112 1162 11B8;D585;1112 1162 11B8; 
    // (햅; 햅; 햅; 햅; 햅; ) HANGUL SYLLABLE HAEB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD585 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD585 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD585 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_046)
{
    // D586;D586;1112 1162 11B9;D586;1112 1162 11B9; 
    // (햆; 햆; 햆; 햆; 햆; ) HANGUL SYLLABLE HAEBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD586 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD586 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD586 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_047)
{
    // D587;D587;1112 1162 11BA;D587;1112 1162 11BA; 
    // (햇; 햇; 햇; 햇; 햇; ) HANGUL SYLLABLE HAES
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD587 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD587 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xD587 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_048)
{
    // D588;D588;1112 1162 11BB;D588;1112 1162 11BB; 
    // (했; 했; 했; 했; 했; ) HANGUL SYLLABLE HAESS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD588 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD588 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xD588 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_049)
{
    // D589;D589;1112 1162 11BC;D589;1112 1162 11BC; 
    // (행; 행; 행; 행; 행; ) HANGUL SYLLABLE HAENG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD589 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD589 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xD589 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_050)
{
    // D58A;D58A;1112 1162 11BD;D58A;1112 1162 11BD; 
    // (햊; 햊; 햊; 햊; 햊; ) HANGUL SYLLABLE HAEJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD58A }};
        std::array<uint32_t, 1> const c2 = {{ 0xD58A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xD58A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_051)
{
    // D58B;D58B;1112 1162 11BE;D58B;1112 1162 11BE; 
    // (햋; 햋; 햋; 햋; 햋; ) HANGUL SYLLABLE HAEC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD58B }};
        std::array<uint32_t, 1> const c2 = {{ 0xD58B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xD58B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_052)
{
    // D58C;D58C;1112 1162 11BF;D58C;1112 1162 11BF; 
    // (햌; 햌; 햌; 햌; 햌; ) HANGUL SYLLABLE HAEK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD58C }};
        std::array<uint32_t, 1> const c2 = {{ 0xD58C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xD58C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_053)
{
    // D58D;D58D;1112 1162 11C0;D58D;1112 1162 11C0; 
    // (햍; 햍; 햍; 햍; 햍; ) HANGUL SYLLABLE HAET
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD58D }};
        std::array<uint32_t, 1> const c2 = {{ 0xD58D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD58D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_054)
{
    // D58E;D58E;1112 1162 11C1;D58E;1112 1162 11C1; 
    // (햎; 햎; 햎; 햎; 햎; ) HANGUL SYLLABLE HAEP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD58E }};
        std::array<uint32_t, 1> const c2 = {{ 0xD58E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD58E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_055)
{
    // D58F;D58F;1112 1162 11C2;D58F;1112 1162 11C2; 
    // (햏; 햏; 햏; 햏; 햏; ) HANGUL SYLLABLE HAEH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD58F }};
        std::array<uint32_t, 1> const c2 = {{ 0xD58F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1162, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD58F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1162, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_056)
{
    // D590;D590;1112 1163;D590;1112 1163; 
    // (햐; 햐; 햐; 햐; 햐; ) HANGUL SYLLABLE HYA
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD590 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD590 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1112, 0x1163 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD590 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1112, 0x1163 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_057)
{
    // D591;D591;1112 1163 11A8;D591;1112 1163 11A8; 
    // (햑; 햑; 햑; 햑; 햑; ) HANGUL SYLLABLE HYAG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD591 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD591 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD591 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_058)
{
    // D592;D592;1112 1163 11A9;D592;1112 1163 11A9; 
    // (햒; 햒; 햒; 햒; 햒; ) HANGUL SYLLABLE HYAGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD592 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD592 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD592 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_059)
{
    // D593;D593;1112 1163 11AA;D593;1112 1163 11AA; 
    // (햓; 햓; 햓; 햓; 햓; ) HANGUL SYLLABLE HYAGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD593 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD593 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xD593 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_060)
{
    // D594;D594;1112 1163 11AB;D594;1112 1163 11AB; 
    // (햔; 햔; 햔; 햔; 햔; ) HANGUL SYLLABLE HYAN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD594 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD594 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xD594 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_061)
{
    // D595;D595;1112 1163 11AC;D595;1112 1163 11AC; 
    // (햕; 햕; 햕; 햕; 햕; ) HANGUL SYLLABLE HYANJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD595 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD595 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xD595 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_062)
{
    // D596;D596;1112 1163 11AD;D596;1112 1163 11AD; 
    // (햖; 햖; 햖; 햖; 햖; ) HANGUL SYLLABLE HYANH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD596 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD596 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xD596 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_063)
{
    // D597;D597;1112 1163 11AE;D597;1112 1163 11AE; 
    // (햗; 햗; 햗; 햗; 햗; ) HANGUL SYLLABLE HYAD
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD597 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD597 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xD597 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_064)
{
    // D598;D598;1112 1163 11AF;D598;1112 1163 11AF; 
    // (햘; 햘; 햘; 햘; 햘; ) HANGUL SYLLABLE HYAL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD598 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD598 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xD598 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_065)
{
    // D599;D599;1112 1163 11B0;D599;1112 1163 11B0; 
    // (햙; 햙; 햙; 햙; 햙; ) HANGUL SYLLABLE HYALG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD599 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD599 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD599 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_066)
{
    // D59A;D59A;1112 1163 11B1;D59A;1112 1163 11B1; 
    // (햚; 햚; 햚; 햚; 햚; ) HANGUL SYLLABLE HYALM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD59A }};
        std::array<uint32_t, 1> const c2 = {{ 0xD59A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD59A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_067)
{
    // D59B;D59B;1112 1163 11B2;D59B;1112 1163 11B2; 
    // (햛; 햛; 햛; 햛; 햛; ) HANGUL SYLLABLE HYALB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD59B }};
        std::array<uint32_t, 1> const c2 = {{ 0xD59B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD59B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_068)
{
    // D59C;D59C;1112 1163 11B3;D59C;1112 1163 11B3; 
    // (햜; 햜; 햜; 햜; 햜; ) HANGUL SYLLABLE HYALS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD59C }};
        std::array<uint32_t, 1> const c2 = {{ 0xD59C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD59C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_069)
{
    // D59D;D59D;1112 1163 11B4;D59D;1112 1163 11B4; 
    // (햝; 햝; 햝; 햝; 햝; ) HANGUL SYLLABLE HYALT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD59D }};
        std::array<uint32_t, 1> const c2 = {{ 0xD59D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD59D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_070)
{
    // D59E;D59E;1112 1163 11B5;D59E;1112 1163 11B5; 
    // (햞; 햞; 햞; 햞; 햞; ) HANGUL SYLLABLE HYALP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD59E }};
        std::array<uint32_t, 1> const c2 = {{ 0xD59E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD59E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_071)
{
    // D59F;D59F;1112 1163 11B6;D59F;1112 1163 11B6; 
    // (햟; 햟; 햟; 햟; 햟; ) HANGUL SYLLABLE HYALH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD59F }};
        std::array<uint32_t, 1> const c2 = {{ 0xD59F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD59F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_072)
{
    // D5A0;D5A0;1112 1163 11B7;D5A0;1112 1163 11B7; 
    // (햠; 햠; 햠; 햠; 햠; ) HANGUL SYLLABLE HYAM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5A0 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5A0 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5A0 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_073)
{
    // D5A1;D5A1;1112 1163 11B8;D5A1;1112 1163 11B8; 
    // (햡; 햡; 햡; 햡; 햡; ) HANGUL SYLLABLE HYAB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5A1 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5A1 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5A1 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_074)
{
    // D5A2;D5A2;1112 1163 11B9;D5A2;1112 1163 11B9; 
    // (햢; 햢; 햢; 햢; 햢; ) HANGUL SYLLABLE HYABS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5A2 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5A2 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5A2 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_075)
{
    // D5A3;D5A3;1112 1163 11BA;D5A3;1112 1163 11BA; 
    // (햣; 햣; 햣; 햣; 햣; ) HANGUL SYLLABLE HYAS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5A3 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5A3 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5A3 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_076)
{
    // D5A4;D5A4;1112 1163 11BB;D5A4;1112 1163 11BB; 
    // (햤; 햤; 햤; 햤; 햤; ) HANGUL SYLLABLE HYASS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5A4 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5A4 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5A4 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_077)
{
    // D5A5;D5A5;1112 1163 11BC;D5A5;1112 1163 11BC; 
    // (향; 향; 향; 향; 향; ) HANGUL SYLLABLE HYANG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5A5 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5A5 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5A5 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_078)
{
    // D5A6;D5A6;1112 1163 11BD;D5A6;1112 1163 11BD; 
    // (햦; 햦; 햦; 햦; 햦; ) HANGUL SYLLABLE HYAJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5A6 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5A6 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5A6 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_079)
{
    // D5A7;D5A7;1112 1163 11BE;D5A7;1112 1163 11BE; 
    // (햧; 햧; 햧; 햧; 햧; ) HANGUL SYLLABLE HYAC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5A7 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5A7 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5A7 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_080)
{
    // D5A8;D5A8;1112 1163 11BF;D5A8;1112 1163 11BF; 
    // (햨; 햨; 햨; 햨; 햨; ) HANGUL SYLLABLE HYAK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5A8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5A8 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5A8 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_081)
{
    // D5A9;D5A9;1112 1163 11C0;D5A9;1112 1163 11C0; 
    // (햩; 햩; 햩; 햩; 햩; ) HANGUL SYLLABLE HYAT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5A9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5A9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5A9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_082)
{
    // D5AA;D5AA;1112 1163 11C1;D5AA;1112 1163 11C1; 
    // (햪; 햪; 햪; 햪; 햪; ) HANGUL SYLLABLE HYAP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5AA }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5AA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5AA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_083)
{
    // D5AB;D5AB;1112 1163 11C2;D5AB;1112 1163 11C2; 
    // (햫; 햫; 햫; 햫; 햫; ) HANGUL SYLLABLE HYAH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5AB }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5AB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1163, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5AB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1163, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_084)
{
    // D5AC;D5AC;1112 1164;D5AC;1112 1164; 
    // (햬; 햬; 햬; 햬; 햬; ) HANGUL SYLLABLE HYAE
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5AC }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5AC }};
        std::array<uint32_t, 2> const c3 = {{ 0x1112, 0x1164 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5AC }};
        std::array<uint32_t, 2> const c5 = {{ 0x1112, 0x1164 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_085)
{
    // D5AD;D5AD;1112 1164 11A8;D5AD;1112 1164 11A8; 
    // (햭; 햭; 햭; 햭; 햭; ) HANGUL SYLLABLE HYAEG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5AD }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5AD }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5AD }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_086)
{
    // D5AE;D5AE;1112 1164 11A9;D5AE;1112 1164 11A9; 
    // (햮; 햮; 햮; 햮; 햮; ) HANGUL SYLLABLE HYAEGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5AE }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5AE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5AE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_087)
{
    // D5AF;D5AF;1112 1164 11AA;D5AF;1112 1164 11AA; 
    // (햯; 햯; 햯; 햯; 햯; ) HANGUL SYLLABLE HYAEGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5AF }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5AF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5AF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_088)
{
    // D5B0;D5B0;1112 1164 11AB;D5B0;1112 1164 11AB; 
    // (햰; 햰; 햰; 햰; 햰; ) HANGUL SYLLABLE HYAEN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5B0 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5B0 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5B0 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_089)
{
    // D5B1;D5B1;1112 1164 11AC;D5B1;1112 1164 11AC; 
    // (햱; 햱; 햱; 햱; 햱; ) HANGUL SYLLABLE HYAENJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5B1 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5B1 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5B1 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_090)
{
    // D5B2;D5B2;1112 1164 11AD;D5B2;1112 1164 11AD; 
    // (햲; 햲; 햲; 햲; 햲; ) HANGUL SYLLABLE HYAENH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5B2 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5B2 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5B2 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_091)
{
    // D5B3;D5B3;1112 1164 11AE;D5B3;1112 1164 11AE; 
    // (햳; 햳; 햳; 햳; 햳; ) HANGUL SYLLABLE HYAED
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5B3 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5B3 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5B3 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_092)
{
    // D5B4;D5B4;1112 1164 11AF;D5B4;1112 1164 11AF; 
    // (햴; 햴; 햴; 햴; 햴; ) HANGUL SYLLABLE HYAEL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5B4 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5B4 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5B4 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_093)
{
    // D5B5;D5B5;1112 1164 11B0;D5B5;1112 1164 11B0; 
    // (햵; 햵; 햵; 햵; 햵; ) HANGUL SYLLABLE HYAELG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5B5 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5B5 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5B5 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_094)
{
    // D5B6;D5B6;1112 1164 11B1;D5B6;1112 1164 11B1; 
    // (햶; 햶; 햶; 햶; 햶; ) HANGUL SYLLABLE HYAELM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5B6 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5B6 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5B6 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_095)
{
    // D5B7;D5B7;1112 1164 11B2;D5B7;1112 1164 11B2; 
    // (햷; 햷; 햷; 햷; 햷; ) HANGUL SYLLABLE HYAELB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5B7 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5B7 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5B7 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_096)
{
    // D5B8;D5B8;1112 1164 11B3;D5B8;1112 1164 11B3; 
    // (햸; 햸; 햸; 햸; 햸; ) HANGUL SYLLABLE HYAELS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5B8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5B8 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5B8 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_097)
{
    // D5B9;D5B9;1112 1164 11B4;D5B9;1112 1164 11B4; 
    // (햹; 햹; 햹; 햹; 햹; ) HANGUL SYLLABLE HYAELT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5B9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5B9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5B9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_098)
{
    // D5BA;D5BA;1112 1164 11B5;D5BA;1112 1164 11B5; 
    // (햺; 햺; 햺; 햺; 햺; ) HANGUL SYLLABLE HYAELP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5BA }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5BA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5BA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_099)
{
    // D5BB;D5BB;1112 1164 11B6;D5BB;1112 1164 11B6; 
    // (햻; 햻; 햻; 햻; 햻; ) HANGUL SYLLABLE HYAELH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5BB }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5BB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5BB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_100)
{
    // D5BC;D5BC;1112 1164 11B7;D5BC;1112 1164 11B7; 
    // (햼; 햼; 햼; 햼; 햼; ) HANGUL SYLLABLE HYAEM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5BC }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5BC }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5BC }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_101)
{
    // D5BD;D5BD;1112 1164 11B8;D5BD;1112 1164 11B8; 
    // (햽; 햽; 햽; 햽; 햽; ) HANGUL SYLLABLE HYAEB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5BD }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5BD }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5BD }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_102)
{
    // D5BE;D5BE;1112 1164 11B9;D5BE;1112 1164 11B9; 
    // (햾; 햾; 햾; 햾; 햾; ) HANGUL SYLLABLE HYAEBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5BE }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5BE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5BE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_103)
{
    // D5BF;D5BF;1112 1164 11BA;D5BF;1112 1164 11BA; 
    // (햿; 햿; 햿; 햿; 햿; ) HANGUL SYLLABLE HYAES
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5BF }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5BF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5BF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_104)
{
    // D5C0;D5C0;1112 1164 11BB;D5C0;1112 1164 11BB; 
    // (헀; 헀; 헀; 헀; 헀; ) HANGUL SYLLABLE HYAESS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5C0 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5C0 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5C0 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_105)
{
    // D5C1;D5C1;1112 1164 11BC;D5C1;1112 1164 11BC; 
    // (헁; 헁; 헁; 헁; 헁; ) HANGUL SYLLABLE HYAENG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5C1 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5C1 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5C1 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_106)
{
    // D5C2;D5C2;1112 1164 11BD;D5C2;1112 1164 11BD; 
    // (헂; 헂; 헂; 헂; 헂; ) HANGUL SYLLABLE HYAEJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5C2 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5C2 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5C2 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_107)
{
    // D5C3;D5C3;1112 1164 11BE;D5C3;1112 1164 11BE; 
    // (헃; 헃; 헃; 헃; 헃; ) HANGUL SYLLABLE HYAEC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5C3 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5C3 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5C3 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_108)
{
    // D5C4;D5C4;1112 1164 11BF;D5C4;1112 1164 11BF; 
    // (헄; 헄; 헄; 헄; 헄; ) HANGUL SYLLABLE HYAEK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5C4 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5C4 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5C4 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_109)
{
    // D5C5;D5C5;1112 1164 11C0;D5C5;1112 1164 11C0; 
    // (헅; 헅; 헅; 헅; 헅; ) HANGUL SYLLABLE HYAET
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5C5 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5C5 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5C5 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_110)
{
    // D5C6;D5C6;1112 1164 11C1;D5C6;1112 1164 11C1; 
    // (헆; 헆; 헆; 헆; 헆; ) HANGUL SYLLABLE HYAEP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5C6 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5C6 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5C6 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_111)
{
    // D5C7;D5C7;1112 1164 11C2;D5C7;1112 1164 11C2; 
    // (헇; 헇; 헇; 헇; 헇; ) HANGUL SYLLABLE HYAEH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5C7 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5C7 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1164, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5C7 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1164, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_112)
{
    // D5C8;D5C8;1112 1165;D5C8;1112 1165; 
    // (허; 허; 허; 허; 허; ) HANGUL SYLLABLE HEO
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5C8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5C8 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1112, 0x1165 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5C8 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1112, 0x1165 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_113)
{
    // D5C9;D5C9;1112 1165 11A8;D5C9;1112 1165 11A8; 
    // (헉; 헉; 헉; 헉; 헉; ) HANGUL SYLLABLE HEOG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5C9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5C9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5C9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_114)
{
    // D5CA;D5CA;1112 1165 11A9;D5CA;1112 1165 11A9; 
    // (헊; 헊; 헊; 헊; 헊; ) HANGUL SYLLABLE HEOGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5CA }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5CA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5CA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_115)
{
    // D5CB;D5CB;1112 1165 11AA;D5CB;1112 1165 11AA; 
    // (헋; 헋; 헋; 헋; 헋; ) HANGUL SYLLABLE HEOGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5CB }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5CB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5CB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_116)
{
    // D5CC;D5CC;1112 1165 11AB;D5CC;1112 1165 11AB; 
    // (헌; 헌; 헌; 헌; 헌; ) HANGUL SYLLABLE HEON
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5CC }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5CC }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5CC }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_117)
{
    // D5CD;D5CD;1112 1165 11AC;D5CD;1112 1165 11AC; 
    // (헍; 헍; 헍; 헍; 헍; ) HANGUL SYLLABLE HEONJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5CD }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5CD }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5CD }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_118)
{
    // D5CE;D5CE;1112 1165 11AD;D5CE;1112 1165 11AD; 
    // (헎; 헎; 헎; 헎; 헎; ) HANGUL SYLLABLE HEONH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5CE }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5CE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5CE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_119)
{
    // D5CF;D5CF;1112 1165 11AE;D5CF;1112 1165 11AE; 
    // (헏; 헏; 헏; 헏; 헏; ) HANGUL SYLLABLE HEOD
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5CF }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5CF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5CF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_120)
{
    // D5D0;D5D0;1112 1165 11AF;D5D0;1112 1165 11AF; 
    // (헐; 헐; 헐; 헐; 헐; ) HANGUL SYLLABLE HEOL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5D0 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5D0 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5D0 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_121)
{
    // D5D1;D5D1;1112 1165 11B0;D5D1;1112 1165 11B0; 
    // (헑; 헑; 헑; 헑; 헑; ) HANGUL SYLLABLE HEOLG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5D1 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5D1 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5D1 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_122)
{
    // D5D2;D5D2;1112 1165 11B1;D5D2;1112 1165 11B1; 
    // (헒; 헒; 헒; 헒; 헒; ) HANGUL SYLLABLE HEOLM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5D2 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5D2 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5D2 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_123)
{
    // D5D3;D5D3;1112 1165 11B2;D5D3;1112 1165 11B2; 
    // (헓; 헓; 헓; 헓; 헓; ) HANGUL SYLLABLE HEOLB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5D3 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5D3 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5D3 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_124)
{
    // D5D4;D5D4;1112 1165 11B3;D5D4;1112 1165 11B3; 
    // (헔; 헔; 헔; 헔; 헔; ) HANGUL SYLLABLE HEOLS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5D4 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5D4 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5D4 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_125)
{
    // D5D5;D5D5;1112 1165 11B4;D5D5;1112 1165 11B4; 
    // (헕; 헕; 헕; 헕; 헕; ) HANGUL SYLLABLE HEOLT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5D5 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5D5 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5D5 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_126)
{
    // D5D6;D5D6;1112 1165 11B5;D5D6;1112 1165 11B5; 
    // (헖; 헖; 헖; 헖; 헖; ) HANGUL SYLLABLE HEOLP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5D6 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5D6 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5D6 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_127)
{
    // D5D7;D5D7;1112 1165 11B6;D5D7;1112 1165 11B6; 
    // (헗; 헗; 헗; 헗; 헗; ) HANGUL SYLLABLE HEOLH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5D7 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5D7 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5D7 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_128)
{
    // D5D8;D5D8;1112 1165 11B7;D5D8;1112 1165 11B7; 
    // (험; 험; 험; 험; 험; ) HANGUL SYLLABLE HEOM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5D8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5D8 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5D8 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_129)
{
    // D5D9;D5D9;1112 1165 11B8;D5D9;1112 1165 11B8; 
    // (헙; 헙; 헙; 헙; 헙; ) HANGUL SYLLABLE HEOB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5D9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5D9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5D9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_130)
{
    // D5DA;D5DA;1112 1165 11B9;D5DA;1112 1165 11B9; 
    // (헚; 헚; 헚; 헚; 헚; ) HANGUL SYLLABLE HEOBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5DA }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5DA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5DA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_131)
{
    // D5DB;D5DB;1112 1165 11BA;D5DB;1112 1165 11BA; 
    // (헛; 헛; 헛; 헛; 헛; ) HANGUL SYLLABLE HEOS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5DB }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5DB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5DB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_132)
{
    // D5DC;D5DC;1112 1165 11BB;D5DC;1112 1165 11BB; 
    // (헜; 헜; 헜; 헜; 헜; ) HANGUL SYLLABLE HEOSS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5DC }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5DC }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5DC }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_133)
{
    // D5DD;D5DD;1112 1165 11BC;D5DD;1112 1165 11BC; 
    // (헝; 헝; 헝; 헝; 헝; ) HANGUL SYLLABLE HEONG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5DD }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5DD }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5DD }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_134)
{
    // D5DE;D5DE;1112 1165 11BD;D5DE;1112 1165 11BD; 
    // (헞; 헞; 헞; 헞; 헞; ) HANGUL SYLLABLE HEOJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5DE }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5DE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5DE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_135)
{
    // D5DF;D5DF;1112 1165 11BE;D5DF;1112 1165 11BE; 
    // (헟; 헟; 헟; 헟; 헟; ) HANGUL SYLLABLE HEOC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5DF }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5DF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5DF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_136)
{
    // D5E0;D5E0;1112 1165 11BF;D5E0;1112 1165 11BF; 
    // (헠; 헠; 헠; 헠; 헠; ) HANGUL SYLLABLE HEOK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5E0 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5E0 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5E0 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_137)
{
    // D5E1;D5E1;1112 1165 11C0;D5E1;1112 1165 11C0; 
    // (헡; 헡; 헡; 헡; 헡; ) HANGUL SYLLABLE HEOT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5E1 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5E1 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5E1 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_138)
{
    // D5E2;D5E2;1112 1165 11C1;D5E2;1112 1165 11C1; 
    // (헢; 헢; 헢; 헢; 헢; ) HANGUL SYLLABLE HEOP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5E2 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5E2 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5E2 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_139)
{
    // D5E3;D5E3;1112 1165 11C2;D5E3;1112 1165 11C2; 
    // (헣; 헣; 헣; 헣; 헣; ) HANGUL SYLLABLE HEOH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5E3 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5E3 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1165, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5E3 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1165, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_140)
{
    // D5E4;D5E4;1112 1166;D5E4;1112 1166; 
    // (헤; 헤; 헤; 헤; 헤; ) HANGUL SYLLABLE HE
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5E4 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5E4 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1112, 0x1166 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5E4 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1112, 0x1166 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_141)
{
    // D5E5;D5E5;1112 1166 11A8;D5E5;1112 1166 11A8; 
    // (헥; 헥; 헥; 헥; 헥; ) HANGUL SYLLABLE HEG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5E5 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5E5 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5E5 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_142)
{
    // D5E6;D5E6;1112 1166 11A9;D5E6;1112 1166 11A9; 
    // (헦; 헦; 헦; 헦; 헦; ) HANGUL SYLLABLE HEGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5E6 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5E6 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5E6 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_143)
{
    // D5E7;D5E7;1112 1166 11AA;D5E7;1112 1166 11AA; 
    // (헧; 헧; 헧; 헧; 헧; ) HANGUL SYLLABLE HEGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5E7 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5E7 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5E7 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_144)
{
    // D5E8;D5E8;1112 1166 11AB;D5E8;1112 1166 11AB; 
    // (헨; 헨; 헨; 헨; 헨; ) HANGUL SYLLABLE HEN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5E8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5E8 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5E8 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_145)
{
    // D5E9;D5E9;1112 1166 11AC;D5E9;1112 1166 11AC; 
    // (헩; 헩; 헩; 헩; 헩; ) HANGUL SYLLABLE HENJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5E9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5E9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5E9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_146)
{
    // D5EA;D5EA;1112 1166 11AD;D5EA;1112 1166 11AD; 
    // (헪; 헪; 헪; 헪; 헪; ) HANGUL SYLLABLE HENH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5EA }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5EA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5EA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_147)
{
    // D5EB;D5EB;1112 1166 11AE;D5EB;1112 1166 11AE; 
    // (헫; 헫; 헫; 헫; 헫; ) HANGUL SYLLABLE HED
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5EB }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5EB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5EB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_148)
{
    // D5EC;D5EC;1112 1166 11AF;D5EC;1112 1166 11AF; 
    // (헬; 헬; 헬; 헬; 헬; ) HANGUL SYLLABLE HEL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5EC }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5EC }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5EC }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_149)
{
    // D5ED;D5ED;1112 1166 11B0;D5ED;1112 1166 11B0; 
    // (헭; 헭; 헭; 헭; 헭; ) HANGUL SYLLABLE HELG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5ED }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5ED }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5ED }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_150)
{
    // D5EE;D5EE;1112 1166 11B1;D5EE;1112 1166 11B1; 
    // (헮; 헮; 헮; 헮; 헮; ) HANGUL SYLLABLE HELM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5EE }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5EE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5EE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_151)
{
    // D5EF;D5EF;1112 1166 11B2;D5EF;1112 1166 11B2; 
    // (헯; 헯; 헯; 헯; 헯; ) HANGUL SYLLABLE HELB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5EF }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5EF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5EF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_152)
{
    // D5F0;D5F0;1112 1166 11B3;D5F0;1112 1166 11B3; 
    // (헰; 헰; 헰; 헰; 헰; ) HANGUL SYLLABLE HELS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5F0 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5F0 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5F0 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_153)
{
    // D5F1;D5F1;1112 1166 11B4;D5F1;1112 1166 11B4; 
    // (헱; 헱; 헱; 헱; 헱; ) HANGUL SYLLABLE HELT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5F1 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5F1 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5F1 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_154)
{
    // D5F2;D5F2;1112 1166 11B5;D5F2;1112 1166 11B5; 
    // (헲; 헲; 헲; 헲; 헲; ) HANGUL SYLLABLE HELP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5F2 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5F2 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5F2 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_155)
{
    // D5F3;D5F3;1112 1166 11B6;D5F3;1112 1166 11B6; 
    // (헳; 헳; 헳; 헳; 헳; ) HANGUL SYLLABLE HELH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5F3 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5F3 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5F3 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_156)
{
    // D5F4;D5F4;1112 1166 11B7;D5F4;1112 1166 11B7; 
    // (헴; 헴; 헴; 헴; 헴; ) HANGUL SYLLABLE HEM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5F4 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5F4 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5F4 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_157)
{
    // D5F5;D5F5;1112 1166 11B8;D5F5;1112 1166 11B8; 
    // (헵; 헵; 헵; 헵; 헵; ) HANGUL SYLLABLE HEB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5F5 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5F5 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5F5 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_158)
{
    // D5F6;D5F6;1112 1166 11B9;D5F6;1112 1166 11B9; 
    // (헶; 헶; 헶; 헶; 헶; ) HANGUL SYLLABLE HEBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5F6 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5F6 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5F6 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_159)
{
    // D5F7;D5F7;1112 1166 11BA;D5F7;1112 1166 11BA; 
    // (헷; 헷; 헷; 헷; 헷; ) HANGUL SYLLABLE HES
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5F7 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5F7 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5F7 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_160)
{
    // D5F8;D5F8;1112 1166 11BB;D5F8;1112 1166 11BB; 
    // (헸; 헸; 헸; 헸; 헸; ) HANGUL SYLLABLE HESS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5F8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5F8 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5F8 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_161)
{
    // D5F9;D5F9;1112 1166 11BC;D5F9;1112 1166 11BC; 
    // (헹; 헹; 헹; 헹; 헹; ) HANGUL SYLLABLE HENG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5F9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5F9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5F9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_162)
{
    // D5FA;D5FA;1112 1166 11BD;D5FA;1112 1166 11BD; 
    // (헺; 헺; 헺; 헺; 헺; ) HANGUL SYLLABLE HEJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5FA }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5FA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5FA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_163)
{
    // D5FB;D5FB;1112 1166 11BE;D5FB;1112 1166 11BE; 
    // (헻; 헻; 헻; 헻; 헻; ) HANGUL SYLLABLE HEC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5FB }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5FB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5FB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_164)
{
    // D5FC;D5FC;1112 1166 11BF;D5FC;1112 1166 11BF; 
    // (헼; 헼; 헼; 헼; 헼; ) HANGUL SYLLABLE HEK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5FC }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5FC }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5FC }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_165)
{
    // D5FD;D5FD;1112 1166 11C0;D5FD;1112 1166 11C0; 
    // (헽; 헽; 헽; 헽; 헽; ) HANGUL SYLLABLE HET
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5FD }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5FD }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5FD }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_166)
{
    // D5FE;D5FE;1112 1166 11C1;D5FE;1112 1166 11C1; 
    // (헾; 헾; 헾; 헾; 헾; ) HANGUL SYLLABLE HEP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5FE }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5FE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5FE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_167)
{
    // D5FF;D5FF;1112 1166 11C2;D5FF;1112 1166 11C2; 
    // (헿; 헿; 헿; 헿; 헿; ) HANGUL SYLLABLE HEH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD5FF }};
        std::array<uint32_t, 1> const c2 = {{ 0xD5FF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1166, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD5FF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1166, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_168)
{
    // D600;D600;1112 1167;D600;1112 1167; 
    // (혀; 혀; 혀; 혀; 혀; ) HANGUL SYLLABLE HYEO
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD600 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD600 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1112, 0x1167 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD600 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1112, 0x1167 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_169)
{
    // D601;D601;1112 1167 11A8;D601;1112 1167 11A8; 
    // (혁; 혁; 혁; 혁; 혁; ) HANGUL SYLLABLE HYEOG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD601 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD601 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD601 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_170)
{
    // D602;D602;1112 1167 11A9;D602;1112 1167 11A9; 
    // (혂; 혂; 혂; 혂; 혂; ) HANGUL SYLLABLE HYEOGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD602 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD602 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD602 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_171)
{
    // D603;D603;1112 1167 11AA;D603;1112 1167 11AA; 
    // (혃; 혃; 혃; 혃; 혃; ) HANGUL SYLLABLE HYEOGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD603 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD603 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xD603 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_172)
{
    // D604;D604;1112 1167 11AB;D604;1112 1167 11AB; 
    // (현; 현; 현; 현; 현; ) HANGUL SYLLABLE HYEON
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD604 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD604 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xD604 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_173)
{
    // D605;D605;1112 1167 11AC;D605;1112 1167 11AC; 
    // (혅; 혅; 혅; 혅; 혅; ) HANGUL SYLLABLE HYEONJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD605 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD605 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xD605 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_174)
{
    // D606;D606;1112 1167 11AD;D606;1112 1167 11AD; 
    // (혆; 혆; 혆; 혆; 혆; ) HANGUL SYLLABLE HYEONH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD606 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD606 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xD606 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_175)
{
    // D607;D607;1112 1167 11AE;D607;1112 1167 11AE; 
    // (혇; 혇; 혇; 혇; 혇; ) HANGUL SYLLABLE HYEOD
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD607 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD607 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xD607 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_176)
{
    // D608;D608;1112 1167 11AF;D608;1112 1167 11AF; 
    // (혈; 혈; 혈; 혈; 혈; ) HANGUL SYLLABLE HYEOL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD608 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD608 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xD608 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_177)
{
    // D609;D609;1112 1167 11B0;D609;1112 1167 11B0; 
    // (혉; 혉; 혉; 혉; 혉; ) HANGUL SYLLABLE HYEOLG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD609 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD609 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD609 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_178)
{
    // D60A;D60A;1112 1167 11B1;D60A;1112 1167 11B1; 
    // (혊; 혊; 혊; 혊; 혊; ) HANGUL SYLLABLE HYEOLM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD60A }};
        std::array<uint32_t, 1> const c2 = {{ 0xD60A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD60A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_179)
{
    // D60B;D60B;1112 1167 11B2;D60B;1112 1167 11B2; 
    // (혋; 혋; 혋; 혋; 혋; ) HANGUL SYLLABLE HYEOLB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD60B }};
        std::array<uint32_t, 1> const c2 = {{ 0xD60B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD60B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_180)
{
    // D60C;D60C;1112 1167 11B3;D60C;1112 1167 11B3; 
    // (혌; 혌; 혌; 혌; 혌; ) HANGUL SYLLABLE HYEOLS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD60C }};
        std::array<uint32_t, 1> const c2 = {{ 0xD60C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD60C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_181)
{
    // D60D;D60D;1112 1167 11B4;D60D;1112 1167 11B4; 
    // (혍; 혍; 혍; 혍; 혍; ) HANGUL SYLLABLE HYEOLT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD60D }};
        std::array<uint32_t, 1> const c2 = {{ 0xD60D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD60D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_182)
{
    // D60E;D60E;1112 1167 11B5;D60E;1112 1167 11B5; 
    // (혎; 혎; 혎; 혎; 혎; ) HANGUL SYLLABLE HYEOLP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD60E }};
        std::array<uint32_t, 1> const c2 = {{ 0xD60E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD60E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_183)
{
    // D60F;D60F;1112 1167 11B6;D60F;1112 1167 11B6; 
    // (혏; 혏; 혏; 혏; 혏; ) HANGUL SYLLABLE HYEOLH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD60F }};
        std::array<uint32_t, 1> const c2 = {{ 0xD60F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD60F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_184)
{
    // D610;D610;1112 1167 11B7;D610;1112 1167 11B7; 
    // (혐; 혐; 혐; 혐; 혐; ) HANGUL SYLLABLE HYEOM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD610 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD610 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD610 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_185)
{
    // D611;D611;1112 1167 11B8;D611;1112 1167 11B8; 
    // (협; 협; 협; 협; 협; ) HANGUL SYLLABLE HYEOB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD611 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD611 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD611 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_186)
{
    // D612;D612;1112 1167 11B9;D612;1112 1167 11B9; 
    // (혒; 혒; 혒; 혒; 혒; ) HANGUL SYLLABLE HYEOBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD612 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD612 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD612 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_187)
{
    // D613;D613;1112 1167 11BA;D613;1112 1167 11BA; 
    // (혓; 혓; 혓; 혓; 혓; ) HANGUL SYLLABLE HYEOS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD613 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD613 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xD613 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_188)
{
    // D614;D614;1112 1167 11BB;D614;1112 1167 11BB; 
    // (혔; 혔; 혔; 혔; 혔; ) HANGUL SYLLABLE HYEOSS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD614 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD614 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xD614 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_189)
{
    // D615;D615;1112 1167 11BC;D615;1112 1167 11BC; 
    // (형; 형; 형; 형; 형; ) HANGUL SYLLABLE HYEONG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD615 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD615 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xD615 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_190)
{
    // D616;D616;1112 1167 11BD;D616;1112 1167 11BD; 
    // (혖; 혖; 혖; 혖; 혖; ) HANGUL SYLLABLE HYEOJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD616 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD616 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xD616 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_191)
{
    // D617;D617;1112 1167 11BE;D617;1112 1167 11BE; 
    // (혗; 혗; 혗; 혗; 혗; ) HANGUL SYLLABLE HYEOC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD617 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD617 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xD617 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_192)
{
    // D618;D618;1112 1167 11BF;D618;1112 1167 11BF; 
    // (혘; 혘; 혘; 혘; 혘; ) HANGUL SYLLABLE HYEOK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD618 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD618 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xD618 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_193)
{
    // D619;D619;1112 1167 11C0;D619;1112 1167 11C0; 
    // (혙; 혙; 혙; 혙; 혙; ) HANGUL SYLLABLE HYEOT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD619 }};
        std::array<uint32_t, 1> const c2 = {{ 0xD619 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD619 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_194)
{
    // D61A;D61A;1112 1167 11C1;D61A;1112 1167 11C1; 
    // (혚; 혚; 혚; 혚; 혚; ) HANGUL SYLLABLE HYEOP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD61A }};
        std::array<uint32_t, 1> const c2 = {{ 0xD61A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD61A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_195)
{
    // D61B;D61B;1112 1167 11C2;D61B;1112 1167 11C2; 
    // (혛; 혛; 혛; 혛; 혛; ) HANGUL SYLLABLE HYEOH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD61B }};
        std::array<uint32_t, 1> const c2 = {{ 0xD61B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1167, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD61B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1167, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_196)
{
    // D61C;D61C;1112 1168;D61C;1112 1168; 
    // (혜; 혜; 혜; 혜; 혜; ) HANGUL SYLLABLE HYE
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD61C }};
        std::array<uint32_t, 1> const c2 = {{ 0xD61C }};
        std::array<uint32_t, 2> const c3 = {{ 0x1112, 0x1168 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD61C }};
        std::array<uint32_t, 2> const c5 = {{ 0x1112, 0x1168 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_197)
{
    // D61D;D61D;1112 1168 11A8;D61D;1112 1168 11A8; 
    // (혝; 혝; 혝; 혝; 혝; ) HANGUL SYLLABLE HYEG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD61D }};
        std::array<uint32_t, 1> const c2 = {{ 0xD61D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1168, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD61D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1168, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_198)
{
    // D61E;D61E;1112 1168 11A9;D61E;1112 1168 11A9; 
    // (혞; 혞; 혞; 혞; 혞; ) HANGUL SYLLABLE HYEGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD61E }};
        std::array<uint32_t, 1> const c2 = {{ 0xD61E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1168, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xD61E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1168, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfd_065_199)
{
    // D61F;D61F;1112 1168 11AA;D61F;1112 1168 11AA; 
    // (혟; 혟; 혟; 혟; 혟; ) HANGUL SYLLABLE HYEGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xD61F }};
        std::array<uint32_t, 1> const c2 = {{ 0xD61F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1112, 0x1168, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xD61F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1112, 0x1168, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c3.size());
            auto c3_it = c3.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c3_it) << "iteration " << i;
                ++c3_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::d>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c5.size());
            auto c5_it = c5.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c5_it) << "iteration " << i;
                ++c5_it;
                ++i;
            }
        }

    }
}


