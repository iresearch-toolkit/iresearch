// Copyright (C) 2020 T. Zachary Laine
//
// Distributed under the Boost Software License, Version 1.0. (See
// accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)

// Warning! This file is autogenerated.
#include <boost/text/normalize_string.hpp>
#include <boost/text/transcode_view.hpp>
#include <boost/text/string_utility.hpp>

#include <gtest/gtest.h>

#include <algorithm>



TEST(normalization, nfkc_013_000)
{
    // ACB8;ACB8;1100 1167 11B7;ACB8;1100 1167 11B7; 
    // (겸; 겸; 겸; 겸; 겸; ) HANGUL SYLLABLE GYEOM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACB8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACB8 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1167, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACB8 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1167, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_001)
{
    // ACB9;ACB9;1100 1167 11B8;ACB9;1100 1167 11B8; 
    // (겹; 겹; 겹; 겹; 겹; ) HANGUL SYLLABLE GYEOB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACB9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACB9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1167, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACB9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1167, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_002)
{
    // ACBA;ACBA;1100 1167 11B9;ACBA;1100 1167 11B9; 
    // (겺; 겺; 겺; 겺; 겺; ) HANGUL SYLLABLE GYEOBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACBA }};
        std::array<uint32_t, 1> const c2 = {{ 0xACBA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1167, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACBA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1167, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_003)
{
    // ACBB;ACBB;1100 1167 11BA;ACBB;1100 1167 11BA; 
    // (겻; 겻; 겻; 겻; 겻; ) HANGUL SYLLABLE GYEOS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACBB }};
        std::array<uint32_t, 1> const c2 = {{ 0xACBB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1167, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xACBB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1167, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_004)
{
    // ACBC;ACBC;1100 1167 11BB;ACBC;1100 1167 11BB; 
    // (겼; 겼; 겼; 겼; 겼; ) HANGUL SYLLABLE GYEOSS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACBC }};
        std::array<uint32_t, 1> const c2 = {{ 0xACBC }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1167, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xACBC }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1167, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_005)
{
    // ACBD;ACBD;1100 1167 11BC;ACBD;1100 1167 11BC; 
    // (경; 경; 경; 경; 경; ) HANGUL SYLLABLE GYEONG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACBD }};
        std::array<uint32_t, 1> const c2 = {{ 0xACBD }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1167, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xACBD }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1167, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_006)
{
    // ACBE;ACBE;1100 1167 11BD;ACBE;1100 1167 11BD; 
    // (겾; 겾; 겾; 겾; 겾; ) HANGUL SYLLABLE GYEOJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACBE }};
        std::array<uint32_t, 1> const c2 = {{ 0xACBE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1167, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xACBE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1167, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_007)
{
    // ACBF;ACBF;1100 1167 11BE;ACBF;1100 1167 11BE; 
    // (겿; 겿; 겿; 겿; 겿; ) HANGUL SYLLABLE GYEOC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACBF }};
        std::array<uint32_t, 1> const c2 = {{ 0xACBF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1167, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xACBF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1167, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_008)
{
    // ACC0;ACC0;1100 1167 11BF;ACC0;1100 1167 11BF; 
    // (곀; 곀; 곀; 곀; 곀; ) HANGUL SYLLABLE GYEOK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACC0 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACC0 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1167, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xACC0 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1167, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_009)
{
    // ACC1;ACC1;1100 1167 11C0;ACC1;1100 1167 11C0; 
    // (곁; 곁; 곁; 곁; 곁; ) HANGUL SYLLABLE GYEOT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACC1 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACC1 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1167, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACC1 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1167, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_010)
{
    // ACC2;ACC2;1100 1167 11C1;ACC2;1100 1167 11C1; 
    // (곂; 곂; 곂; 곂; 곂; ) HANGUL SYLLABLE GYEOP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACC2 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACC2 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1167, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACC2 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1167, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_011)
{
    // ACC3;ACC3;1100 1167 11C2;ACC3;1100 1167 11C2; 
    // (곃; 곃; 곃; 곃; 곃; ) HANGUL SYLLABLE GYEOH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACC3 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACC3 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1167, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACC3 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1167, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_012)
{
    // ACC4;ACC4;1100 1168;ACC4;1100 1168; 
    // (계; 계; 계; 계; 계; ) HANGUL SYLLABLE GYE
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACC4 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACC4 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1100, 0x1168 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACC4 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1100, 0x1168 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_013)
{
    // ACC5;ACC5;1100 1168 11A8;ACC5;1100 1168 11A8; 
    // (곅; 곅; 곅; 곅; 곅; ) HANGUL SYLLABLE GYEG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACC5 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACC5 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACC5 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_014)
{
    // ACC6;ACC6;1100 1168 11A9;ACC6;1100 1168 11A9; 
    // (곆; 곆; 곆; 곆; 곆; ) HANGUL SYLLABLE GYEGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACC6 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACC6 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACC6 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_015)
{
    // ACC7;ACC7;1100 1168 11AA;ACC7;1100 1168 11AA; 
    // (곇; 곇; 곇; 곇; 곇; ) HANGUL SYLLABLE GYEGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACC7 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACC7 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xACC7 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_016)
{
    // ACC8;ACC8;1100 1168 11AB;ACC8;1100 1168 11AB; 
    // (곈; 곈; 곈; 곈; 곈; ) HANGUL SYLLABLE GYEN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACC8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACC8 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xACC8 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_017)
{
    // ACC9;ACC9;1100 1168 11AC;ACC9;1100 1168 11AC; 
    // (곉; 곉; 곉; 곉; 곉; ) HANGUL SYLLABLE GYENJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACC9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACC9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xACC9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_018)
{
    // ACCA;ACCA;1100 1168 11AD;ACCA;1100 1168 11AD; 
    // (곊; 곊; 곊; 곊; 곊; ) HANGUL SYLLABLE GYENH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACCA }};
        std::array<uint32_t, 1> const c2 = {{ 0xACCA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xACCA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_019)
{
    // ACCB;ACCB;1100 1168 11AE;ACCB;1100 1168 11AE; 
    // (곋; 곋; 곋; 곋; 곋; ) HANGUL SYLLABLE GYED
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACCB }};
        std::array<uint32_t, 1> const c2 = {{ 0xACCB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xACCB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_020)
{
    // ACCC;ACCC;1100 1168 11AF;ACCC;1100 1168 11AF; 
    // (곌; 곌; 곌; 곌; 곌; ) HANGUL SYLLABLE GYEL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACCC }};
        std::array<uint32_t, 1> const c2 = {{ 0xACCC }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xACCC }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_021)
{
    // ACCD;ACCD;1100 1168 11B0;ACCD;1100 1168 11B0; 
    // (곍; 곍; 곍; 곍; 곍; ) HANGUL SYLLABLE GYELG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACCD }};
        std::array<uint32_t, 1> const c2 = {{ 0xACCD }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACCD }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_022)
{
    // ACCE;ACCE;1100 1168 11B1;ACCE;1100 1168 11B1; 
    // (곎; 곎; 곎; 곎; 곎; ) HANGUL SYLLABLE GYELM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACCE }};
        std::array<uint32_t, 1> const c2 = {{ 0xACCE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACCE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_023)
{
    // ACCF;ACCF;1100 1168 11B2;ACCF;1100 1168 11B2; 
    // (곏; 곏; 곏; 곏; 곏; ) HANGUL SYLLABLE GYELB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACCF }};
        std::array<uint32_t, 1> const c2 = {{ 0xACCF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACCF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_024)
{
    // ACD0;ACD0;1100 1168 11B3;ACD0;1100 1168 11B3; 
    // (곐; 곐; 곐; 곐; 곐; ) HANGUL SYLLABLE GYELS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACD0 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACD0 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACD0 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_025)
{
    // ACD1;ACD1;1100 1168 11B4;ACD1;1100 1168 11B4; 
    // (곑; 곑; 곑; 곑; 곑; ) HANGUL SYLLABLE GYELT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACD1 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACD1 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACD1 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_026)
{
    // ACD2;ACD2;1100 1168 11B5;ACD2;1100 1168 11B5; 
    // (곒; 곒; 곒; 곒; 곒; ) HANGUL SYLLABLE GYELP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACD2 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACD2 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACD2 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_027)
{
    // ACD3;ACD3;1100 1168 11B6;ACD3;1100 1168 11B6; 
    // (곓; 곓; 곓; 곓; 곓; ) HANGUL SYLLABLE GYELH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACD3 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACD3 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACD3 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_028)
{
    // ACD4;ACD4;1100 1168 11B7;ACD4;1100 1168 11B7; 
    // (곔; 곔; 곔; 곔; 곔; ) HANGUL SYLLABLE GYEM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACD4 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACD4 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACD4 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_029)
{
    // ACD5;ACD5;1100 1168 11B8;ACD5;1100 1168 11B8; 
    // (곕; 곕; 곕; 곕; 곕; ) HANGUL SYLLABLE GYEB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACD5 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACD5 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACD5 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_030)
{
    // ACD6;ACD6;1100 1168 11B9;ACD6;1100 1168 11B9; 
    // (곖; 곖; 곖; 곖; 곖; ) HANGUL SYLLABLE GYEBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACD6 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACD6 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACD6 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_031)
{
    // ACD7;ACD7;1100 1168 11BA;ACD7;1100 1168 11BA; 
    // (곗; 곗; 곗; 곗; 곗; ) HANGUL SYLLABLE GYES
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACD7 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACD7 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xACD7 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_032)
{
    // ACD8;ACD8;1100 1168 11BB;ACD8;1100 1168 11BB; 
    // (곘; 곘; 곘; 곘; 곘; ) HANGUL SYLLABLE GYESS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACD8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACD8 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xACD8 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_033)
{
    // ACD9;ACD9;1100 1168 11BC;ACD9;1100 1168 11BC; 
    // (곙; 곙; 곙; 곙; 곙; ) HANGUL SYLLABLE GYENG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACD9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACD9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xACD9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_034)
{
    // ACDA;ACDA;1100 1168 11BD;ACDA;1100 1168 11BD; 
    // (곚; 곚; 곚; 곚; 곚; ) HANGUL SYLLABLE GYEJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACDA }};
        std::array<uint32_t, 1> const c2 = {{ 0xACDA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xACDA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_035)
{
    // ACDB;ACDB;1100 1168 11BE;ACDB;1100 1168 11BE; 
    // (곛; 곛; 곛; 곛; 곛; ) HANGUL SYLLABLE GYEC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACDB }};
        std::array<uint32_t, 1> const c2 = {{ 0xACDB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xACDB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_036)
{
    // ACDC;ACDC;1100 1168 11BF;ACDC;1100 1168 11BF; 
    // (곜; 곜; 곜; 곜; 곜; ) HANGUL SYLLABLE GYEK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACDC }};
        std::array<uint32_t, 1> const c2 = {{ 0xACDC }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xACDC }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_037)
{
    // ACDD;ACDD;1100 1168 11C0;ACDD;1100 1168 11C0; 
    // (곝; 곝; 곝; 곝; 곝; ) HANGUL SYLLABLE GYET
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACDD }};
        std::array<uint32_t, 1> const c2 = {{ 0xACDD }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACDD }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_038)
{
    // ACDE;ACDE;1100 1168 11C1;ACDE;1100 1168 11C1; 
    // (곞; 곞; 곞; 곞; 곞; ) HANGUL SYLLABLE GYEP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACDE }};
        std::array<uint32_t, 1> const c2 = {{ 0xACDE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACDE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_039)
{
    // ACDF;ACDF;1100 1168 11C2;ACDF;1100 1168 11C2; 
    // (곟; 곟; 곟; 곟; 곟; ) HANGUL SYLLABLE GYEH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACDF }};
        std::array<uint32_t, 1> const c2 = {{ 0xACDF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1168, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACDF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1168, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_040)
{
    // ACE0;ACE0;1100 1169;ACE0;1100 1169; 
    // (고; 고; 고; 고; 고; ) HANGUL SYLLABLE GO
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACE0 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACE0 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1100, 0x1169 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACE0 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1100, 0x1169 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_041)
{
    // ACE1;ACE1;1100 1169 11A8;ACE1;1100 1169 11A8; 
    // (곡; 곡; 곡; 곡; 곡; ) HANGUL SYLLABLE GOG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACE1 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACE1 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACE1 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_042)
{
    // ACE2;ACE2;1100 1169 11A9;ACE2;1100 1169 11A9; 
    // (곢; 곢; 곢; 곢; 곢; ) HANGUL SYLLABLE GOGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACE2 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACE2 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACE2 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_043)
{
    // ACE3;ACE3;1100 1169 11AA;ACE3;1100 1169 11AA; 
    // (곣; 곣; 곣; 곣; 곣; ) HANGUL SYLLABLE GOGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACE3 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACE3 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xACE3 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_044)
{
    // ACE4;ACE4;1100 1169 11AB;ACE4;1100 1169 11AB; 
    // (곤; 곤; 곤; 곤; 곤; ) HANGUL SYLLABLE GON
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACE4 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACE4 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xACE4 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_045)
{
    // ACE5;ACE5;1100 1169 11AC;ACE5;1100 1169 11AC; 
    // (곥; 곥; 곥; 곥; 곥; ) HANGUL SYLLABLE GONJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACE5 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACE5 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xACE5 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_046)
{
    // ACE6;ACE6;1100 1169 11AD;ACE6;1100 1169 11AD; 
    // (곦; 곦; 곦; 곦; 곦; ) HANGUL SYLLABLE GONH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACE6 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACE6 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xACE6 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_047)
{
    // ACE7;ACE7;1100 1169 11AE;ACE7;1100 1169 11AE; 
    // (곧; 곧; 곧; 곧; 곧; ) HANGUL SYLLABLE GOD
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACE7 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACE7 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xACE7 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_048)
{
    // ACE8;ACE8;1100 1169 11AF;ACE8;1100 1169 11AF; 
    // (골; 골; 골; 골; 골; ) HANGUL SYLLABLE GOL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACE8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACE8 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xACE8 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_049)
{
    // ACE9;ACE9;1100 1169 11B0;ACE9;1100 1169 11B0; 
    // (곩; 곩; 곩; 곩; 곩; ) HANGUL SYLLABLE GOLG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACE9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACE9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACE9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_050)
{
    // ACEA;ACEA;1100 1169 11B1;ACEA;1100 1169 11B1; 
    // (곪; 곪; 곪; 곪; 곪; ) HANGUL SYLLABLE GOLM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACEA }};
        std::array<uint32_t, 1> const c2 = {{ 0xACEA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACEA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_051)
{
    // ACEB;ACEB;1100 1169 11B2;ACEB;1100 1169 11B2; 
    // (곫; 곫; 곫; 곫; 곫; ) HANGUL SYLLABLE GOLB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACEB }};
        std::array<uint32_t, 1> const c2 = {{ 0xACEB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACEB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_052)
{
    // ACEC;ACEC;1100 1169 11B3;ACEC;1100 1169 11B3; 
    // (곬; 곬; 곬; 곬; 곬; ) HANGUL SYLLABLE GOLS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACEC }};
        std::array<uint32_t, 1> const c2 = {{ 0xACEC }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACEC }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_053)
{
    // ACED;ACED;1100 1169 11B4;ACED;1100 1169 11B4; 
    // (곭; 곭; 곭; 곭; 곭; ) HANGUL SYLLABLE GOLT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACED }};
        std::array<uint32_t, 1> const c2 = {{ 0xACED }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACED }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_054)
{
    // ACEE;ACEE;1100 1169 11B5;ACEE;1100 1169 11B5; 
    // (곮; 곮; 곮; 곮; 곮; ) HANGUL SYLLABLE GOLP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACEE }};
        std::array<uint32_t, 1> const c2 = {{ 0xACEE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACEE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_055)
{
    // ACEF;ACEF;1100 1169 11B6;ACEF;1100 1169 11B6; 
    // (곯; 곯; 곯; 곯; 곯; ) HANGUL SYLLABLE GOLH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACEF }};
        std::array<uint32_t, 1> const c2 = {{ 0xACEF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACEF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_056)
{
    // ACF0;ACF0;1100 1169 11B7;ACF0;1100 1169 11B7; 
    // (곰; 곰; 곰; 곰; 곰; ) HANGUL SYLLABLE GOM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACF0 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACF0 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACF0 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_057)
{
    // ACF1;ACF1;1100 1169 11B8;ACF1;1100 1169 11B8; 
    // (곱; 곱; 곱; 곱; 곱; ) HANGUL SYLLABLE GOB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACF1 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACF1 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACF1 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_058)
{
    // ACF2;ACF2;1100 1169 11B9;ACF2;1100 1169 11B9; 
    // (곲; 곲; 곲; 곲; 곲; ) HANGUL SYLLABLE GOBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACF2 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACF2 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACF2 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_059)
{
    // ACF3;ACF3;1100 1169 11BA;ACF3;1100 1169 11BA; 
    // (곳; 곳; 곳; 곳; 곳; ) HANGUL SYLLABLE GOS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACF3 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACF3 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xACF3 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_060)
{
    // ACF4;ACF4;1100 1169 11BB;ACF4;1100 1169 11BB; 
    // (곴; 곴; 곴; 곴; 곴; ) HANGUL SYLLABLE GOSS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACF4 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACF4 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xACF4 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_061)
{
    // ACF5;ACF5;1100 1169 11BC;ACF5;1100 1169 11BC; 
    // (공; 공; 공; 공; 공; ) HANGUL SYLLABLE GONG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACF5 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACF5 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xACF5 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_062)
{
    // ACF6;ACF6;1100 1169 11BD;ACF6;1100 1169 11BD; 
    // (곶; 곶; 곶; 곶; 곶; ) HANGUL SYLLABLE GOJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACF6 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACF6 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xACF6 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_063)
{
    // ACF7;ACF7;1100 1169 11BE;ACF7;1100 1169 11BE; 
    // (곷; 곷; 곷; 곷; 곷; ) HANGUL SYLLABLE GOC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACF7 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACF7 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xACF7 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_064)
{
    // ACF8;ACF8;1100 1169 11BF;ACF8;1100 1169 11BF; 
    // (곸; 곸; 곸; 곸; 곸; ) HANGUL SYLLABLE GOK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACF8 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACF8 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xACF8 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_065)
{
    // ACF9;ACF9;1100 1169 11C0;ACF9;1100 1169 11C0; 
    // (곹; 곹; 곹; 곹; 곹; ) HANGUL SYLLABLE GOT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACF9 }};
        std::array<uint32_t, 1> const c2 = {{ 0xACF9 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACF9 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_066)
{
    // ACFA;ACFA;1100 1169 11C1;ACFA;1100 1169 11C1; 
    // (곺; 곺; 곺; 곺; 곺; ) HANGUL SYLLABLE GOP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACFA }};
        std::array<uint32_t, 1> const c2 = {{ 0xACFA }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACFA }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_067)
{
    // ACFB;ACFB;1100 1169 11C2;ACFB;1100 1169 11C2; 
    // (곻; 곻; 곻; 곻; 곻; ) HANGUL SYLLABLE GOH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACFB }};
        std::array<uint32_t, 1> const c2 = {{ 0xACFB }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x1169, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACFB }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x1169, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_068)
{
    // ACFC;ACFC;1100 116A;ACFC;1100 116A; 
    // (과; 과; 과; 과; 과; ) HANGUL SYLLABLE GWA
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACFC }};
        std::array<uint32_t, 1> const c2 = {{ 0xACFC }};
        std::array<uint32_t, 2> const c3 = {{ 0x1100, 0x116A }};
        std::array<uint32_t, 1> const c4 = {{ 0xACFC }};
        std::array<uint32_t, 2> const c5 = {{ 0x1100, 0x116A }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_069)
{
    // ACFD;ACFD;1100 116A 11A8;ACFD;1100 116A 11A8; 
    // (곽; 곽; 곽; 곽; 곽; ) HANGUL SYLLABLE GWAG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACFD }};
        std::array<uint32_t, 1> const c2 = {{ 0xACFD }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACFD }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_070)
{
    // ACFE;ACFE;1100 116A 11A9;ACFE;1100 116A 11A9; 
    // (곾; 곾; 곾; 곾; 곾; ) HANGUL SYLLABLE GWAGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACFE }};
        std::array<uint32_t, 1> const c2 = {{ 0xACFE }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xACFE }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_071)
{
    // ACFF;ACFF;1100 116A 11AA;ACFF;1100 116A 11AA; 
    // (곿; 곿; 곿; 곿; 곿; ) HANGUL SYLLABLE GWAGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xACFF }};
        std::array<uint32_t, 1> const c2 = {{ 0xACFF }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xACFF }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_072)
{
    // AD00;AD00;1100 116A 11AB;AD00;1100 116A 11AB; 
    // (관; 관; 관; 관; 관; ) HANGUL SYLLABLE GWAN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD00 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD00 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD00 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_073)
{
    // AD01;AD01;1100 116A 11AC;AD01;1100 116A 11AC; 
    // (괁; 괁; 괁; 괁; 괁; ) HANGUL SYLLABLE GWANJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD01 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD01 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD01 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_074)
{
    // AD02;AD02;1100 116A 11AD;AD02;1100 116A 11AD; 
    // (괂; 괂; 괂; 괂; 괂; ) HANGUL SYLLABLE GWANH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD02 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD02 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD02 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_075)
{
    // AD03;AD03;1100 116A 11AE;AD03;1100 116A 11AE; 
    // (괃; 괃; 괃; 괃; 괃; ) HANGUL SYLLABLE GWAD
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD03 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD03 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD03 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_076)
{
    // AD04;AD04;1100 116A 11AF;AD04;1100 116A 11AF; 
    // (괄; 괄; 괄; 괄; 괄; ) HANGUL SYLLABLE GWAL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD04 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD04 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD04 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_077)
{
    // AD05;AD05;1100 116A 11B0;AD05;1100 116A 11B0; 
    // (괅; 괅; 괅; 괅; 괅; ) HANGUL SYLLABLE GWALG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD05 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD05 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD05 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_078)
{
    // AD06;AD06;1100 116A 11B1;AD06;1100 116A 11B1; 
    // (괆; 괆; 괆; 괆; 괆; ) HANGUL SYLLABLE GWALM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD06 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD06 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD06 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_079)
{
    // AD07;AD07;1100 116A 11B2;AD07;1100 116A 11B2; 
    // (괇; 괇; 괇; 괇; 괇; ) HANGUL SYLLABLE GWALB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD07 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD07 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD07 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_080)
{
    // AD08;AD08;1100 116A 11B3;AD08;1100 116A 11B3; 
    // (괈; 괈; 괈; 괈; 괈; ) HANGUL SYLLABLE GWALS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD08 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD08 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD08 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_081)
{
    // AD09;AD09;1100 116A 11B4;AD09;1100 116A 11B4; 
    // (괉; 괉; 괉; 괉; 괉; ) HANGUL SYLLABLE GWALT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD09 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD09 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD09 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_082)
{
    // AD0A;AD0A;1100 116A 11B5;AD0A;1100 116A 11B5; 
    // (괊; 괊; 괊; 괊; 괊; ) HANGUL SYLLABLE GWALP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD0A }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD0A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD0A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_083)
{
    // AD0B;AD0B;1100 116A 11B6;AD0B;1100 116A 11B6; 
    // (괋; 괋; 괋; 괋; 괋; ) HANGUL SYLLABLE GWALH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD0B }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD0B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD0B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_084)
{
    // AD0C;AD0C;1100 116A 11B7;AD0C;1100 116A 11B7; 
    // (괌; 괌; 괌; 괌; 괌; ) HANGUL SYLLABLE GWAM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD0C }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD0C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD0C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_085)
{
    // AD0D;AD0D;1100 116A 11B8;AD0D;1100 116A 11B8; 
    // (괍; 괍; 괍; 괍; 괍; ) HANGUL SYLLABLE GWAB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD0D }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD0D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD0D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_086)
{
    // AD0E;AD0E;1100 116A 11B9;AD0E;1100 116A 11B9; 
    // (괎; 괎; 괎; 괎; 괎; ) HANGUL SYLLABLE GWABS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD0E }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD0E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD0E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_087)
{
    // AD0F;AD0F;1100 116A 11BA;AD0F;1100 116A 11BA; 
    // (괏; 괏; 괏; 괏; 괏; ) HANGUL SYLLABLE GWAS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD0F }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD0F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD0F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_088)
{
    // AD10;AD10;1100 116A 11BB;AD10;1100 116A 11BB; 
    // (괐; 괐; 괐; 괐; 괐; ) HANGUL SYLLABLE GWASS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD10 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD10 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD10 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_089)
{
    // AD11;AD11;1100 116A 11BC;AD11;1100 116A 11BC; 
    // (광; 광; 광; 광; 광; ) HANGUL SYLLABLE GWANG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD11 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD11 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD11 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_090)
{
    // AD12;AD12;1100 116A 11BD;AD12;1100 116A 11BD; 
    // (괒; 괒; 괒; 괒; 괒; ) HANGUL SYLLABLE GWAJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD12 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD12 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD12 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_091)
{
    // AD13;AD13;1100 116A 11BE;AD13;1100 116A 11BE; 
    // (괓; 괓; 괓; 괓; 괓; ) HANGUL SYLLABLE GWAC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD13 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD13 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD13 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_092)
{
    // AD14;AD14;1100 116A 11BF;AD14;1100 116A 11BF; 
    // (괔; 괔; 괔; 괔; 괔; ) HANGUL SYLLABLE GWAK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD14 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD14 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD14 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_093)
{
    // AD15;AD15;1100 116A 11C0;AD15;1100 116A 11C0; 
    // (괕; 괕; 괕; 괕; 괕; ) HANGUL SYLLABLE GWAT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD15 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD15 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD15 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_094)
{
    // AD16;AD16;1100 116A 11C1;AD16;1100 116A 11C1; 
    // (괖; 괖; 괖; 괖; 괖; ) HANGUL SYLLABLE GWAP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD16 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD16 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD16 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_095)
{
    // AD17;AD17;1100 116A 11C2;AD17;1100 116A 11C2; 
    // (괗; 괗; 괗; 괗; 괗; ) HANGUL SYLLABLE GWAH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD17 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD17 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116A, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD17 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116A, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_096)
{
    // AD18;AD18;1100 116B;AD18;1100 116B; 
    // (괘; 괘; 괘; 괘; 괘; ) HANGUL SYLLABLE GWAE
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD18 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD18 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1100, 0x116B }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD18 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1100, 0x116B }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_097)
{
    // AD19;AD19;1100 116B 11A8;AD19;1100 116B 11A8; 
    // (괙; 괙; 괙; 괙; 괙; ) HANGUL SYLLABLE GWAEG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD19 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD19 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD19 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_098)
{
    // AD1A;AD1A;1100 116B 11A9;AD1A;1100 116B 11A9; 
    // (괚; 괚; 괚; 괚; 괚; ) HANGUL SYLLABLE GWAEGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD1A }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD1A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD1A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_099)
{
    // AD1B;AD1B;1100 116B 11AA;AD1B;1100 116B 11AA; 
    // (괛; 괛; 괛; 괛; 괛; ) HANGUL SYLLABLE GWAEGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD1B }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD1B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD1B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_100)
{
    // AD1C;AD1C;1100 116B 11AB;AD1C;1100 116B 11AB; 
    // (괜; 괜; 괜; 괜; 괜; ) HANGUL SYLLABLE GWAEN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD1C }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD1C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD1C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_101)
{
    // AD1D;AD1D;1100 116B 11AC;AD1D;1100 116B 11AC; 
    // (괝; 괝; 괝; 괝; 괝; ) HANGUL SYLLABLE GWAENJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD1D }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD1D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD1D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_102)
{
    // AD1E;AD1E;1100 116B 11AD;AD1E;1100 116B 11AD; 
    // (괞; 괞; 괞; 괞; 괞; ) HANGUL SYLLABLE GWAENH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD1E }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD1E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD1E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_103)
{
    // AD1F;AD1F;1100 116B 11AE;AD1F;1100 116B 11AE; 
    // (괟; 괟; 괟; 괟; 괟; ) HANGUL SYLLABLE GWAED
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD1F }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD1F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD1F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_104)
{
    // AD20;AD20;1100 116B 11AF;AD20;1100 116B 11AF; 
    // (괠; 괠; 괠; 괠; 괠; ) HANGUL SYLLABLE GWAEL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD20 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD20 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD20 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_105)
{
    // AD21;AD21;1100 116B 11B0;AD21;1100 116B 11B0; 
    // (괡; 괡; 괡; 괡; 괡; ) HANGUL SYLLABLE GWAELG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD21 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD21 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD21 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_106)
{
    // AD22;AD22;1100 116B 11B1;AD22;1100 116B 11B1; 
    // (괢; 괢; 괢; 괢; 괢; ) HANGUL SYLLABLE GWAELM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD22 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD22 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD22 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_107)
{
    // AD23;AD23;1100 116B 11B2;AD23;1100 116B 11B2; 
    // (괣; 괣; 괣; 괣; 괣; ) HANGUL SYLLABLE GWAELB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD23 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD23 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD23 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_108)
{
    // AD24;AD24;1100 116B 11B3;AD24;1100 116B 11B3; 
    // (괤; 괤; 괤; 괤; 괤; ) HANGUL SYLLABLE GWAELS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD24 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD24 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD24 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_109)
{
    // AD25;AD25;1100 116B 11B4;AD25;1100 116B 11B4; 
    // (괥; 괥; 괥; 괥; 괥; ) HANGUL SYLLABLE GWAELT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD25 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD25 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD25 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_110)
{
    // AD26;AD26;1100 116B 11B5;AD26;1100 116B 11B5; 
    // (괦; 괦; 괦; 괦; 괦; ) HANGUL SYLLABLE GWAELP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD26 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD26 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD26 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_111)
{
    // AD27;AD27;1100 116B 11B6;AD27;1100 116B 11B6; 
    // (괧; 괧; 괧; 괧; 괧; ) HANGUL SYLLABLE GWAELH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD27 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD27 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD27 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_112)
{
    // AD28;AD28;1100 116B 11B7;AD28;1100 116B 11B7; 
    // (괨; 괨; 괨; 괨; 괨; ) HANGUL SYLLABLE GWAEM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD28 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD28 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD28 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_113)
{
    // AD29;AD29;1100 116B 11B8;AD29;1100 116B 11B8; 
    // (괩; 괩; 괩; 괩; 괩; ) HANGUL SYLLABLE GWAEB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD29 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD29 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD29 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_114)
{
    // AD2A;AD2A;1100 116B 11B9;AD2A;1100 116B 11B9; 
    // (괪; 괪; 괪; 괪; 괪; ) HANGUL SYLLABLE GWAEBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD2A }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD2A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD2A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_115)
{
    // AD2B;AD2B;1100 116B 11BA;AD2B;1100 116B 11BA; 
    // (괫; 괫; 괫; 괫; 괫; ) HANGUL SYLLABLE GWAES
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD2B }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD2B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD2B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_116)
{
    // AD2C;AD2C;1100 116B 11BB;AD2C;1100 116B 11BB; 
    // (괬; 괬; 괬; 괬; 괬; ) HANGUL SYLLABLE GWAESS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD2C }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD2C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD2C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_117)
{
    // AD2D;AD2D;1100 116B 11BC;AD2D;1100 116B 11BC; 
    // (괭; 괭; 괭; 괭; 괭; ) HANGUL SYLLABLE GWAENG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD2D }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD2D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD2D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_118)
{
    // AD2E;AD2E;1100 116B 11BD;AD2E;1100 116B 11BD; 
    // (괮; 괮; 괮; 괮; 괮; ) HANGUL SYLLABLE GWAEJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD2E }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD2E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD2E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_119)
{
    // AD2F;AD2F;1100 116B 11BE;AD2F;1100 116B 11BE; 
    // (괯; 괯; 괯; 괯; 괯; ) HANGUL SYLLABLE GWAEC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD2F }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD2F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD2F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_120)
{
    // AD30;AD30;1100 116B 11BF;AD30;1100 116B 11BF; 
    // (괰; 괰; 괰; 괰; 괰; ) HANGUL SYLLABLE GWAEK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD30 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD30 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD30 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_121)
{
    // AD31;AD31;1100 116B 11C0;AD31;1100 116B 11C0; 
    // (괱; 괱; 괱; 괱; 괱; ) HANGUL SYLLABLE GWAET
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD31 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD31 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD31 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_122)
{
    // AD32;AD32;1100 116B 11C1;AD32;1100 116B 11C1; 
    // (괲; 괲; 괲; 괲; 괲; ) HANGUL SYLLABLE GWAEP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD32 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD32 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD32 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_123)
{
    // AD33;AD33;1100 116B 11C2;AD33;1100 116B 11C2; 
    // (괳; 괳; 괳; 괳; 괳; ) HANGUL SYLLABLE GWAEH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD33 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD33 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116B, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD33 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116B, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_124)
{
    // AD34;AD34;1100 116C;AD34;1100 116C; 
    // (괴; 괴; 괴; 괴; 괴; ) HANGUL SYLLABLE GOE
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD34 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD34 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1100, 0x116C }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD34 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1100, 0x116C }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_125)
{
    // AD35;AD35;1100 116C 11A8;AD35;1100 116C 11A8; 
    // (괵; 괵; 괵; 괵; 괵; ) HANGUL SYLLABLE GOEG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD35 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD35 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD35 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_126)
{
    // AD36;AD36;1100 116C 11A9;AD36;1100 116C 11A9; 
    // (괶; 괶; 괶; 괶; 괶; ) HANGUL SYLLABLE GOEGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD36 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD36 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD36 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_127)
{
    // AD37;AD37;1100 116C 11AA;AD37;1100 116C 11AA; 
    // (괷; 괷; 괷; 괷; 괷; ) HANGUL SYLLABLE GOEGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD37 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD37 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD37 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_128)
{
    // AD38;AD38;1100 116C 11AB;AD38;1100 116C 11AB; 
    // (괸; 괸; 괸; 괸; 괸; ) HANGUL SYLLABLE GOEN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD38 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD38 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD38 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_129)
{
    // AD39;AD39;1100 116C 11AC;AD39;1100 116C 11AC; 
    // (괹; 괹; 괹; 괹; 괹; ) HANGUL SYLLABLE GOENJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD39 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD39 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD39 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_130)
{
    // AD3A;AD3A;1100 116C 11AD;AD3A;1100 116C 11AD; 
    // (괺; 괺; 괺; 괺; 괺; ) HANGUL SYLLABLE GOENH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD3A }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD3A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD3A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_131)
{
    // AD3B;AD3B;1100 116C 11AE;AD3B;1100 116C 11AE; 
    // (괻; 괻; 괻; 괻; 괻; ) HANGUL SYLLABLE GOED
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD3B }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD3B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD3B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_132)
{
    // AD3C;AD3C;1100 116C 11AF;AD3C;1100 116C 11AF; 
    // (괼; 괼; 괼; 괼; 괼; ) HANGUL SYLLABLE GOEL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD3C }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD3C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD3C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_133)
{
    // AD3D;AD3D;1100 116C 11B0;AD3D;1100 116C 11B0; 
    // (괽; 괽; 괽; 괽; 괽; ) HANGUL SYLLABLE GOELG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD3D }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD3D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD3D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_134)
{
    // AD3E;AD3E;1100 116C 11B1;AD3E;1100 116C 11B1; 
    // (괾; 괾; 괾; 괾; 괾; ) HANGUL SYLLABLE GOELM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD3E }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD3E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD3E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_135)
{
    // AD3F;AD3F;1100 116C 11B2;AD3F;1100 116C 11B2; 
    // (괿; 괿; 괿; 괿; 괿; ) HANGUL SYLLABLE GOELB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD3F }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD3F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD3F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_136)
{
    // AD40;AD40;1100 116C 11B3;AD40;1100 116C 11B3; 
    // (굀; 굀; 굀; 굀; 굀; ) HANGUL SYLLABLE GOELS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD40 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD40 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD40 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_137)
{
    // AD41;AD41;1100 116C 11B4;AD41;1100 116C 11B4; 
    // (굁; 굁; 굁; 굁; 굁; ) HANGUL SYLLABLE GOELT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD41 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD41 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD41 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_138)
{
    // AD42;AD42;1100 116C 11B5;AD42;1100 116C 11B5; 
    // (굂; 굂; 굂; 굂; 굂; ) HANGUL SYLLABLE GOELP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD42 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD42 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD42 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_139)
{
    // AD43;AD43;1100 116C 11B6;AD43;1100 116C 11B6; 
    // (굃; 굃; 굃; 굃; 굃; ) HANGUL SYLLABLE GOELH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD43 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD43 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD43 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_140)
{
    // AD44;AD44;1100 116C 11B7;AD44;1100 116C 11B7; 
    // (굄; 굄; 굄; 굄; 굄; ) HANGUL SYLLABLE GOEM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD44 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD44 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD44 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_141)
{
    // AD45;AD45;1100 116C 11B8;AD45;1100 116C 11B8; 
    // (굅; 굅; 굅; 굅; 굅; ) HANGUL SYLLABLE GOEB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD45 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD45 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD45 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_142)
{
    // AD46;AD46;1100 116C 11B9;AD46;1100 116C 11B9; 
    // (굆; 굆; 굆; 굆; 굆; ) HANGUL SYLLABLE GOEBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD46 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD46 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD46 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_143)
{
    // AD47;AD47;1100 116C 11BA;AD47;1100 116C 11BA; 
    // (굇; 굇; 굇; 굇; 굇; ) HANGUL SYLLABLE GOES
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD47 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD47 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD47 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_144)
{
    // AD48;AD48;1100 116C 11BB;AD48;1100 116C 11BB; 
    // (굈; 굈; 굈; 굈; 굈; ) HANGUL SYLLABLE GOESS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD48 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD48 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD48 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_145)
{
    // AD49;AD49;1100 116C 11BC;AD49;1100 116C 11BC; 
    // (굉; 굉; 굉; 굉; 굉; ) HANGUL SYLLABLE GOENG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD49 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD49 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD49 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_146)
{
    // AD4A;AD4A;1100 116C 11BD;AD4A;1100 116C 11BD; 
    // (굊; 굊; 굊; 굊; 굊; ) HANGUL SYLLABLE GOEJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD4A }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD4A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD4A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_147)
{
    // AD4B;AD4B;1100 116C 11BE;AD4B;1100 116C 11BE; 
    // (굋; 굋; 굋; 굋; 굋; ) HANGUL SYLLABLE GOEC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD4B }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD4B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD4B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_148)
{
    // AD4C;AD4C;1100 116C 11BF;AD4C;1100 116C 11BF; 
    // (굌; 굌; 굌; 굌; 굌; ) HANGUL SYLLABLE GOEK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD4C }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD4C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD4C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_149)
{
    // AD4D;AD4D;1100 116C 11C0;AD4D;1100 116C 11C0; 
    // (굍; 굍; 굍; 굍; 굍; ) HANGUL SYLLABLE GOET
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD4D }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD4D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD4D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_150)
{
    // AD4E;AD4E;1100 116C 11C1;AD4E;1100 116C 11C1; 
    // (굎; 굎; 굎; 굎; 굎; ) HANGUL SYLLABLE GOEP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD4E }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD4E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD4E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_151)
{
    // AD4F;AD4F;1100 116C 11C2;AD4F;1100 116C 11C2; 
    // (굏; 굏; 굏; 굏; 굏; ) HANGUL SYLLABLE GOEH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD4F }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD4F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116C, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD4F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116C, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_152)
{
    // AD50;AD50;1100 116D;AD50;1100 116D; 
    // (교; 교; 교; 교; 교; ) HANGUL SYLLABLE GYO
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD50 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD50 }};
        std::array<uint32_t, 2> const c3 = {{ 0x1100, 0x116D }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD50 }};
        std::array<uint32_t, 2> const c5 = {{ 0x1100, 0x116D }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_153)
{
    // AD51;AD51;1100 116D 11A8;AD51;1100 116D 11A8; 
    // (굑; 굑; 굑; 굑; 굑; ) HANGUL SYLLABLE GYOG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD51 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD51 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD51 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_154)
{
    // AD52;AD52;1100 116D 11A9;AD52;1100 116D 11A9; 
    // (굒; 굒; 굒; 굒; 굒; ) HANGUL SYLLABLE GYOGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD52 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD52 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD52 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_155)
{
    // AD53;AD53;1100 116D 11AA;AD53;1100 116D 11AA; 
    // (굓; 굓; 굓; 굓; 굓; ) HANGUL SYLLABLE GYOGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD53 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD53 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD53 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_156)
{
    // AD54;AD54;1100 116D 11AB;AD54;1100 116D 11AB; 
    // (굔; 굔; 굔; 굔; 굔; ) HANGUL SYLLABLE GYON
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD54 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD54 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD54 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_157)
{
    // AD55;AD55;1100 116D 11AC;AD55;1100 116D 11AC; 
    // (굕; 굕; 굕; 굕; 굕; ) HANGUL SYLLABLE GYONJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD55 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD55 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD55 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_158)
{
    // AD56;AD56;1100 116D 11AD;AD56;1100 116D 11AD; 
    // (굖; 굖; 굖; 굖; 굖; ) HANGUL SYLLABLE GYONH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD56 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD56 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD56 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_159)
{
    // AD57;AD57;1100 116D 11AE;AD57;1100 116D 11AE; 
    // (굗; 굗; 굗; 굗; 굗; ) HANGUL SYLLABLE GYOD
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD57 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD57 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD57 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_160)
{
    // AD58;AD58;1100 116D 11AF;AD58;1100 116D 11AF; 
    // (굘; 굘; 굘; 굘; 굘; ) HANGUL SYLLABLE GYOL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD58 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD58 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD58 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_161)
{
    // AD59;AD59;1100 116D 11B0;AD59;1100 116D 11B0; 
    // (굙; 굙; 굙; 굙; 굙; ) HANGUL SYLLABLE GYOLG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD59 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD59 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD59 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_162)
{
    // AD5A;AD5A;1100 116D 11B1;AD5A;1100 116D 11B1; 
    // (굚; 굚; 굚; 굚; 굚; ) HANGUL SYLLABLE GYOLM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD5A }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD5A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD5A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_163)
{
    // AD5B;AD5B;1100 116D 11B2;AD5B;1100 116D 11B2; 
    // (굛; 굛; 굛; 굛; 굛; ) HANGUL SYLLABLE GYOLB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD5B }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD5B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD5B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_164)
{
    // AD5C;AD5C;1100 116D 11B3;AD5C;1100 116D 11B3; 
    // (굜; 굜; 굜; 굜; 굜; ) HANGUL SYLLABLE GYOLS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD5C }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD5C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD5C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_165)
{
    // AD5D;AD5D;1100 116D 11B4;AD5D;1100 116D 11B4; 
    // (굝; 굝; 굝; 굝; 굝; ) HANGUL SYLLABLE GYOLT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD5D }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD5D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD5D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_166)
{
    // AD5E;AD5E;1100 116D 11B5;AD5E;1100 116D 11B5; 
    // (굞; 굞; 굞; 굞; 굞; ) HANGUL SYLLABLE GYOLP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD5E }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD5E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD5E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_167)
{
    // AD5F;AD5F;1100 116D 11B6;AD5F;1100 116D 11B6; 
    // (굟; 굟; 굟; 굟; 굟; ) HANGUL SYLLABLE GYOLH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD5F }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD5F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD5F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_168)
{
    // AD60;AD60;1100 116D 11B7;AD60;1100 116D 11B7; 
    // (굠; 굠; 굠; 굠; 굠; ) HANGUL SYLLABLE GYOM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD60 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD60 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD60 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_169)
{
    // AD61;AD61;1100 116D 11B8;AD61;1100 116D 11B8; 
    // (굡; 굡; 굡; 굡; 굡; ) HANGUL SYLLABLE GYOB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD61 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD61 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD61 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_170)
{
    // AD62;AD62;1100 116D 11B9;AD62;1100 116D 11B9; 
    // (굢; 굢; 굢; 굢; 굢; ) HANGUL SYLLABLE GYOBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD62 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD62 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD62 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_171)
{
    // AD63;AD63;1100 116D 11BA;AD63;1100 116D 11BA; 
    // (굣; 굣; 굣; 굣; 굣; ) HANGUL SYLLABLE GYOS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD63 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD63 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD63 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_172)
{
    // AD64;AD64;1100 116D 11BB;AD64;1100 116D 11BB; 
    // (굤; 굤; 굤; 굤; 굤; ) HANGUL SYLLABLE GYOSS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD64 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD64 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11BB }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD64 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11BB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_173)
{
    // AD65;AD65;1100 116D 11BC;AD65;1100 116D 11BC; 
    // (굥; 굥; 굥; 굥; 굥; ) HANGUL SYLLABLE GYONG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD65 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD65 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11BC }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD65 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11BC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_174)
{
    // AD66;AD66;1100 116D 11BD;AD66;1100 116D 11BD; 
    // (굦; 굦; 굦; 굦; 굦; ) HANGUL SYLLABLE GYOJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD66 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD66 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11BD }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD66 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11BD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_175)
{
    // AD67;AD67;1100 116D 11BE;AD67;1100 116D 11BE; 
    // (굧; 굧; 굧; 굧; 굧; ) HANGUL SYLLABLE GYOC
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD67 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD67 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11BE }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD67 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11BE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_176)
{
    // AD68;AD68;1100 116D 11BF;AD68;1100 116D 11BF; 
    // (굨; 굨; 굨; 굨; 굨; ) HANGUL SYLLABLE GYOK
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD68 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD68 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11BF }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD68 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11BF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_177)
{
    // AD69;AD69;1100 116D 11C0;AD69;1100 116D 11C0; 
    // (굩; 굩; 굩; 굩; 굩; ) HANGUL SYLLABLE GYOT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD69 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD69 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11C0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD69 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11C0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_178)
{
    // AD6A;AD6A;1100 116D 11C1;AD6A;1100 116D 11C1; 
    // (굪; 굪; 굪; 굪; 굪; ) HANGUL SYLLABLE GYOP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD6A }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD6A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11C1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD6A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11C1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_179)
{
    // AD6B;AD6B;1100 116D 11C2;AD6B;1100 116D 11C2; 
    // (굫; 굫; 굫; 굫; 굫; ) HANGUL SYLLABLE GYOH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD6B }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD6B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116D, 0x11C2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD6B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116D, 0x11C2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_180)
{
    // AD6C;AD6C;1100 116E;AD6C;1100 116E; 
    // (구; 구; 구; 구; 구; ) HANGUL SYLLABLE GU
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD6C }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD6C }};
        std::array<uint32_t, 2> const c3 = {{ 0x1100, 0x116E }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD6C }};
        std::array<uint32_t, 2> const c5 = {{ 0x1100, 0x116E }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_181)
{
    // AD6D;AD6D;1100 116E 11A8;AD6D;1100 116E 11A8; 
    // (국; 국; 국; 국; 국; ) HANGUL SYLLABLE GUG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD6D }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD6D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11A8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD6D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11A8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_182)
{
    // AD6E;AD6E;1100 116E 11A9;AD6E;1100 116E 11A9; 
    // (굮; 굮; 굮; 굮; 굮; ) HANGUL SYLLABLE GUGG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD6E }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD6E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11A9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD6E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11A9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_183)
{
    // AD6F;AD6F;1100 116E 11AA;AD6F;1100 116E 11AA; 
    // (굯; 굯; 굯; 굯; 굯; ) HANGUL SYLLABLE GUGS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD6F }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD6F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11AA }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD6F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11AA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_184)
{
    // AD70;AD70;1100 116E 11AB;AD70;1100 116E 11AB; 
    // (군; 군; 군; 군; 군; ) HANGUL SYLLABLE GUN
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD70 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD70 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11AB }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD70 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11AB }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_185)
{
    // AD71;AD71;1100 116E 11AC;AD71;1100 116E 11AC; 
    // (굱; 굱; 굱; 굱; 굱; ) HANGUL SYLLABLE GUNJ
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD71 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD71 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11AC }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD71 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11AC }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_186)
{
    // AD72;AD72;1100 116E 11AD;AD72;1100 116E 11AD; 
    // (굲; 굲; 굲; 굲; 굲; ) HANGUL SYLLABLE GUNH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD72 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD72 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11AD }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD72 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11AD }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_187)
{
    // AD73;AD73;1100 116E 11AE;AD73;1100 116E 11AE; 
    // (굳; 굳; 굳; 굳; 굳; ) HANGUL SYLLABLE GUD
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD73 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD73 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11AE }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD73 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11AE }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_188)
{
    // AD74;AD74;1100 116E 11AF;AD74;1100 116E 11AF; 
    // (굴; 굴; 굴; 굴; 굴; ) HANGUL SYLLABLE GUL
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD74 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD74 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11AF }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD74 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11AF }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_189)
{
    // AD75;AD75;1100 116E 11B0;AD75;1100 116E 11B0; 
    // (굵; 굵; 굵; 굵; 굵; ) HANGUL SYLLABLE GULG
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD75 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD75 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11B0 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD75 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11B0 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_190)
{
    // AD76;AD76;1100 116E 11B1;AD76;1100 116E 11B1; 
    // (굶; 굶; 굶; 굶; 굶; ) HANGUL SYLLABLE GULM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD76 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD76 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11B1 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD76 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11B1 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_191)
{
    // AD77;AD77;1100 116E 11B2;AD77;1100 116E 11B2; 
    // (굷; 굷; 굷; 굷; 굷; ) HANGUL SYLLABLE GULB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD77 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD77 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11B2 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD77 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11B2 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_192)
{
    // AD78;AD78;1100 116E 11B3;AD78;1100 116E 11B3; 
    // (굸; 굸; 굸; 굸; 굸; ) HANGUL SYLLABLE GULS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD78 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD78 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11B3 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD78 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11B3 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_193)
{
    // AD79;AD79;1100 116E 11B4;AD79;1100 116E 11B4; 
    // (굹; 굹; 굹; 굹; 굹; ) HANGUL SYLLABLE GULT
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD79 }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD79 }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11B4 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD79 }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11B4 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_194)
{
    // AD7A;AD7A;1100 116E 11B5;AD7A;1100 116E 11B5; 
    // (굺; 굺; 굺; 굺; 굺; ) HANGUL SYLLABLE GULP
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD7A }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD7A }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11B5 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD7A }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11B5 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_195)
{
    // AD7B;AD7B;1100 116E 11B6;AD7B;1100 116E 11B6; 
    // (굻; 굻; 굻; 굻; 굻; ) HANGUL SYLLABLE GULH
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD7B }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD7B }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11B6 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD7B }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11B6 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_196)
{
    // AD7C;AD7C;1100 116E 11B7;AD7C;1100 116E 11B7; 
    // (굼; 굼; 굼; 굼; 굼; ) HANGUL SYLLABLE GUM
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD7C }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD7C }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11B7 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD7C }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11B7 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_197)
{
    // AD7D;AD7D;1100 116E 11B8;AD7D;1100 116E 11B8; 
    // (굽; 굽; 굽; 굽; 굽; ) HANGUL SYLLABLE GUB
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD7D }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD7D }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11B8 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD7D }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11B8 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_198)
{
    // AD7E;AD7E;1100 116E 11B9;AD7E;1100 116E 11B9; 
    // (굾; 굾; 굾; 굾; 굾; ) HANGUL SYLLABLE GUBS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD7E }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD7E }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11B9 }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD7E }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11B9 }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


TEST(normalization, nfkc_013_199)
{
    // AD7F;AD7F;1100 116E 11BA;AD7F;1100 116E 11BA; 
    // (굿; 굿; 굿; 굿; 굿; ) HANGUL SYLLABLE GUS
    {
        std::array<uint32_t, 1> const c1 = {{ 0xAD7F }};
        std::array<uint32_t, 1> const c2 = {{ 0xAD7F }};
        std::array<uint32_t, 3> const c3 = {{ 0x1100, 0x116E, 0x11BA }};
        std::array<uint32_t, 1> const c4 = {{ 0xAD7F }};
        std::array<uint32_t, 3> const c5 = {{ 0x1100, 0x116E, 0x11BA }};

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c2.begin(), c2.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c2.begin(), c2.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c3.begin(), c3.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c3.begin(), c3.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::c>(c4.begin(), c4.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kc>(c4.begin(), c4.end()));

        EXPECT_TRUE(boost::text::normalized<boost::text::nf::d>(c5.begin(), c5.end()));
        EXPECT_TRUE(boost::text::normalized<boost::text::nf::kd>(c5.begin(), c5.end()));



        {
            std::string str = boost::text::to_string(c1.begin(), c1.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c2.begin(), c2.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c3.begin(), c3.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c4.begin(), c4.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

        {
            std::string str = boost::text::to_string(c5.begin(), c5.end());
            boost::text::normalize<boost::text::nf::kc>(str);
            auto const r = boost::text::as_utf32(str);
            EXPECT_EQ(std::distance(r.begin(), r.end()), (std::ptrdiff_t)c4.size());
            auto c4_it = c4.begin();
            int i = 0;
            for (auto x : r) {
                EXPECT_EQ(x, *c4_it) << "iteration " << i;
                ++c4_it;
                ++i;
            }
        }

    }
}


